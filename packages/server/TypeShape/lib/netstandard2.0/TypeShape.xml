<?xml version="1.0" encoding="utf-8"?>
<doc>
<assembly><name>TypeShape</name></assembly>
<members>
<member name="P:TypeShape.Core.Core.ShapePoco`1.Properties">
<summary>
 Property shapes for the type
</summary>
</member>
<member name="P:TypeShape.Core.Core.ShapePoco`1.IsStruct">
<summary>
 True iff POCO is a struct
</summary>
</member>
<member name="P:TypeShape.Core.Core.ShapePoco`1.IsCSharpRecord">
<summary>
 True iff POCO is a C# 9 record
</summary>
</member>
<member name="P:TypeShape.Core.Core.ShapePoco`1.Fields">
<summary>
 Field shapes for the type
</summary>
</member>
<member name="P:TypeShape.Core.Core.ShapePoco`1.Constructors">
<summary>
 Constructor shapes for the type
</summary>
</member>
<member name="M:TypeShape.Core.Core.ShapePoco`1.CreateUninitializedExpr">
<summary>
 Creates an uninitialized instance for POCO
</summary>
</member>
<member name="M:TypeShape.Core.Core.ShapePoco`1.CreateUninitialized">
<summary>
 Creates an uninitialized instance for POCO
</summary>
</member>
<member name="T:TypeShape.Core.Core.ShapePoco`1">
<summary>
 Denotes any .NET type that is either a class or a struct
</summary>
</member>
<member name="P:TypeShape.Core.Core.IShapePoco.Properties">
<summary>
 Property shapes for the type
</summary>
</member>
<member name="P:TypeShape.Core.Core.IShapePoco.IsStruct">
<summary>
 True iff POCO is a struct
</summary>
</member>
<member name="P:TypeShape.Core.Core.IShapePoco.IsCSharpRecord">
<summary>
 True iff POCO is a C# 9 record
</summary>
</member>
<member name="P:TypeShape.Core.Core.IShapePoco.Fields">
<summary>
 Field shapes for the type
</summary>
</member>
<member name="P:TypeShape.Core.Core.IShapePoco.Constructors">
<summary>
 Constructor shapes for the type
</summary>
</member>
<member name="T:TypeShape.Core.Core.IShapePoco">
<summary>
 Denotes any .NET type that is either a class or a struct
</summary>
</member>
<member name="P:TypeShape.Core.Core.ShapeCliMutable`1.Properties">
<summary>
 Property shapes for C# record
</summary>
</member>
<member name="P:TypeShape.Core.Core.ShapeCliMutable`1.DefaultCtorInfo">
<summary>
 Gets the default constructor info defined in the type
</summary>
</member>
<member name="M:TypeShape.Core.Core.ShapeCliMutable`1.CreateUninitializedExpr">
<summary>
 Creates an uninitialized instance for given C# record
</summary>
</member>
<member name="M:TypeShape.Core.Core.ShapeCliMutable`1.CreateUninitialized">
<summary>
 Creates an uninitialized instance for given C# record
</summary>
</member>
<member name="T:TypeShape.Core.Core.ShapeCliMutable`1">
<summary>
 Denotes a type that behaves like a C# record:
 Carries a parameterless constructor and settable properties
</summary>
</member>
<member name="P:TypeShape.Core.Core.IShapeCliMutable.Properties">
<summary>
 Gettable and Settable properties for C# DTO
</summary>
</member>
<member name="T:TypeShape.Core.Core.IShapeCliMutable">
<summary>
 Denotes a type that behaves like a mutable C# DTO:
 Carries a parameterless constructor and settable properties
</summary>
</member>
<member name="P:TypeShape.Core.Core.ShapeFSharpUnion`1.UnionCases">
<summary>
 Case shapes for given union type
</summary>
</member>
<member name="M:TypeShape.Core.Core.ShapeFSharpUnion`1.GetTag(System.String)">
<summary>
 Gets the underlying tag id for given union case name
</summary>
</member>
<member name="M:TypeShape.Core.Core.ShapeFSharpUnion`1.GetTag(`0)">
<summary>
 Gets the underlying tag id for given union instance
</summary>
</member>
<member name="T:TypeShape.Core.Core.ShapeFSharpUnion`1">
<summary>
 Denotes an F# Union shape
</summary>
</member>
<member name="P:TypeShape.Core.Core.IShapeFSharpUnion.UnionCases">
<summary>
 Case shapes for given union type
</summary>
</member>
<member name="T:TypeShape.Core.Core.IShapeFSharpUnion">
<summary>
 Denotes an F# Union shape
</summary>
</member>
<member name="P:TypeShape.Core.Core.ShapeFSharpUnionCase`1.Fields">
<summary>
 Field shapes for union case
</summary>
</member>
<member name="P:TypeShape.Core.Core.ShapeFSharpUnionCase`1.CaseInfo">
<summary>
 Underlying FSharp.Reflection.UnionCaseInfo description
</summary>
</member>
<member name="P:TypeShape.Core.Core.ShapeFSharpUnionCase`1.Arity">
<summary>
 Number of fields in the particular union case
</summary>
</member>
<member name="M:TypeShape.Core.Core.ShapeFSharpUnionCase`1.CreateUninitialized">
<summary>
 Creates an uninitialized instance for specific union case
</summary>
</member>
<member name="T:TypeShape.Core.Core.ShapeFSharpUnionCase`1">
<summary>
 Denotes an F# union case shape
</summary>
</member>
<member name="P:TypeShape.Core.Core.IShapeFSharpUnionCase.Fields">
<summary>
 Field shapes for union case
</summary>
</member>
<member name="P:TypeShape.Core.Core.IShapeFSharpUnionCase.CaseInfo">
<summary>
 Underlying FSharp.Reflection.UnionCaseInfo description
</summary>
</member>
<member name="T:TypeShape.Core.Core.IShapeFSharpUnionCase">
<summary>
 Denotes an F# union case shape
</summary>
</member>
<member name="P:TypeShape.Core.Core.ShapeFSharpRecord`1.IsStructRecord">
<summary>
 True if an F# struct record
</summary>
</member>
<member name="P:TypeShape.Core.Core.ShapeFSharpRecord`1.IsAnonymousRecord">
<summary>
 True if F# 4.6 anonyous records
</summary>
</member>
<member name="P:TypeShape.Core.Core.ShapeFSharpRecord`1.Fields">
<summary>
 F# record field shapes
</summary>
</member>
<member name="M:TypeShape.Core.Core.ShapeFSharpRecord`1.CreateUninitialized">
<summary>
 Creates an uninitialized instance for given record
</summary>
</member>
<member name="T:TypeShape.Core.Core.ShapeFSharpRecord`1">
<summary>
 Identifies an F# record type
</summary>
</member>
<member name="P:TypeShape.Core.Core.IShapeFSharpRecord.Fields">
<summary>
 F# record field shapes
</summary>
</member>
<member name="T:TypeShape.Core.Core.IShapeFSharpRecord">
<summary>
 Denotes an F# record type
</summary>
</member>
<member name="P:TypeShape.Core.Core.ShapeTuple`1.Elements">
<summary>
 Tuple element shape definitions
</summary>
</member>
<member name="M:TypeShape.Core.Core.ShapeTuple`1.CreateUninitialized">
<summary>
 Creates an uninitialized tuple instance of given type
</summary>
</member>
<member name="T:TypeShape.Core.Core.ShapeTuple`1">
<summary>
 Identifies a specific System.Tuple shape
</summary>
</member>
<member name="P:TypeShape.Core.Core.IShapeTuple.Elements">
<summary>
 Tuple element shape definitions
</summary>
</member>
<member name="T:TypeShape.Core.Core.IShapeTuple">
<summary>
 Denotes a specific System.Tuple shape
</summary>
</member>
<member name="M:TypeShape.Core.Core.ShapeConstructor`2.InvokeExpr(Microsoft.FSharp.Quotations.FSharpExpr{`1})">
<summary>
 Creates an instance of declaring type with supplied constructor args
</summary>
</member>
<member name="M:TypeShape.Core.Core.ShapeConstructor`2.Invoke(`1)">
<summary>
 Creates an instance of declaring type with supplied constructor args
</summary>
</member>
<member name="T:TypeShape.Core.Core.ShapeConstructor`2">
<summary>
 Identifies a constructor implementation shape
</summary>
</member>
<member name="T:TypeShape.Core.Core.IShapeConstructor`1">
<summary>
 Identifies a constructor implementation shape
</summary>
</member>
<member name="P:TypeShape.Core.Core.IShapeConstructor.IsPublic">
<summary>
 Denotes whether constructor is public
</summary>
</member>
<member name="P:TypeShape.Core.Core.IShapeConstructor.ConstructorInfo">
<summary>
 ConstructorInfo instance
</summary>
</member>
<member name="P:TypeShape.Core.Core.IShapeConstructor.Arity">
<summary>
 Denotes the arity of the constructor arguments
</summary>
</member>
<member name="T:TypeShape.Core.Core.IShapeConstructor">
<summary>
 Identifies a constructor implementation shape
</summary>
</member>
<member name="M:TypeShape.Core.Core.ShapeMember`2.SetExpr(Microsoft.FSharp.Quotations.FSharpExpr{`0},Microsoft.FSharp.Quotations.FSharpExpr{`1})">
<summary>
 Injects a value to member of given instance
</summary>
</member>
<member name="M:TypeShape.Core.Core.ShapeMember`2.Set(`0,`1)">
<summary>
 Assigns value to the provided instance. NB this is a mutating operation
</summary>
</member>
<member name="M:TypeShape.Core.Core.ShapeMember`2.Inject(`0,`1)">
<summary>
 Assigns value to the provided instance. NB this is a mutating operation
</summary>
</member>
<member name="T:TypeShape.Core.Core.ShapeMember`2">
<summary>
 Identifies an instance member that defines
 a mutable value in a class instance, typically a field or property
</summary>
</member>
<member name="T:TypeShape.Core.Core.IShapeMember`1">
<summary>
 Identifies an instance member that defines
 a mutable value in a class instance, typically a field or property
</summary>
</member>
<member name="P:TypeShape.Core.Core.ReadOnlyMember`2.MemberInfo">
<summary>
 The actual System.Reflection.MemberInfo corresponding to member
</summary>
</member>
<member name="P:TypeShape.Core.Core.ReadOnlyMember`2.Label">
<summary>
 Human-readable member identifier
</summary>
</member>
<member name="P:TypeShape.Core.Core.ReadOnlyMember`2.IsStructMember">
<summary>
 True iff member is contained within a struct
</summary>
</member>
<member name="P:TypeShape.Core.Core.ReadOnlyMember`2.IsPublic">
<summary>
 True iff member is public
</summary>
</member>
<member name="M:TypeShape.Core.Core.ReadOnlyMember`2.Project(`0)">
<summary>
 Gets the current value from the given declaring type instance
</summary>
</member>
<member name="M:TypeShape.Core.Core.ReadOnlyMember`2.GetExpr(Microsoft.FSharp.Quotations.FSharpExpr{`0})">
<summary>
 Projects an instance to member of given value
</summary>
</member>
<member name="M:TypeShape.Core.Core.ReadOnlyMember`2.Get(`0)">
<summary>
 Gets the current value from the given declaring type instance
</summary>
</member>
<member name="T:TypeShape.Core.Core.ReadOnlyMember`2">
<summary>
 Identifies an instance member that defines a read-only value
 in a class instance, typically a field or property
</summary>
</member>
<member name="T:TypeShape.Core.Core.IShapeReadOnlyMember`1">
<summary>
 Identifies an instance member that defines a read-only value
 in a class instance, typically a field or property
</summary>
</member>
<member name="P:TypeShape.Core.Core.IShapeReadOnlyMember.MemberInfo">
<summary>
 The actual System.Reflection.MemberInfo corresponding to member
</summary>
</member>
<member name="P:TypeShape.Core.Core.IShapeReadOnlyMember.Member">
<summary>
 Type of value stored by member
</summary>
</member>
<member name="P:TypeShape.Core.Core.IShapeReadOnlyMember.Label">
<summary>
 Human-readable member identifier
</summary>
</member>
<member name="P:TypeShape.Core.Core.IShapeReadOnlyMember.IsStructMember">
<summary>
 True iff member is contained within a struct
</summary>
</member>
<member name="P:TypeShape.Core.Core.IShapeReadOnlyMember.IsPublic">
<summary>
 True iff member is public
</summary>
</member>
<member name="T:TypeShape.Core.Core.IShapeReadOnlyMember">
<summary>
 Identifies an instance member that defines a read-only value
 in a class instance, typically a field or property
</summary>
</member>
<member name="P:TypeShape.Core.Core.IShapeArray.Rank">
<summary>
 Gets the rank of the array type shape
</summary>
</member>
<member name="T:TypeShape.Core.Core.TypeShape`1">
<summary>
 Encapsulates a type variable that can be accessed using type shape visitors
</summary>
</member>
<member name="M:TypeShape.Core.Core.TypeShape.FromValue(System.Object)">
 <summary>
     Creates a type shape instance from the underlying
     type of a given value.
 </summary>
 <param name="obj">Non-null value to extract shape data from.</param>
</member>
<member name="M:TypeShape.Core.Core.TypeShape.Create``1">
 <summary>
     Creates a type shape instance for given type
 </summary>
</member>
<member name="M:TypeShape.Core.Core.TypeShape.Create(System.Type)">
 <summary>
     Creates a type shape instance for given type
 </summary>
 <param name="typ">System.Type to be resolved.</param>
</member>
<member name="T:TypeShape.Core.Core.TypeShape">
<summary>
 Encapsulates a type variable that can be accessed using type shape visitors
</summary>
</member>
<member name="T:TypeShape.Core.Core.ITypeVisitor`1">
<summary>
 Used to extract the type variable contained in a specific shape
</summary>
</member>
<member name="T:TypeShape.Core.Core.TypeShapeInfo">
<summary>
 Provides a simple breakdown of basic kinds of types.
 Used for easier extraction of type shapes in the active pattern implementations.
</summary>
</member>
<member name="M:TypeShape.Core.Core.shapeof``1">
<summary>
 Creates a type shape instance for given type
</summary>
</member>
<member name="M:TypeShape.Core.Core.Type.IsInterfaceAssignableFrom(System.Type,System.Type)">
<summary>
 Correctly resolves if type is assignable to interface
</summary>
</member>
<member name="M:TypeShape.Core.Core.Activator.CreateInstanceGeneric.Static``1(Microsoft.FSharp.Core.FSharpOption{System.Type[]},Microsoft.FSharp.Core.FSharpOption{System.Object[]})">
<summary>
 Generic edition of the activator method which support type parameters and private types
</summary>
</member>
<member name="M:TypeShape.Core.Core.Shape.|Poco|_|(TypeShape.Core.Core.TypeShape)">
<summary>
 Recognizes POCO shapes, .NET types that are either classes, structs or C# records types
</summary>
</member>
<member name="M:TypeShape.Core.Core.Shape.|CliMutable|_|(TypeShape.Core.Core.TypeShape)">
<summary>
 Recognizes shapes that look like C# record classes
 They are classes with parameterless constructors and settable properties
</summary>
</member>
<member name="M:TypeShape.Core.Core.Shape.|Tuple|_|(TypeShape.Core.Core.TypeShape)">
<summary>
 Recognizes shapes that are System.Tuple instances of arbitrary arity
</summary>
</member>
<member name="M:TypeShape.Core.Core.Shape.|FSharpUnion|_|(TypeShape.Core.Core.TypeShape)">
<summary>
 Recognizes shapes that are F# unions
</summary>
</member>
<member name="M:TypeShape.Core.Core.Shape.|FSharpRecord|_|(TypeShape.Core.Core.TypeShape)">
<summary>
 Recognizes shapes that are F# records
</summary>
</member>
<member name="M:TypeShape.Core.Core.Shape.|Enumerable|_|(TypeShape.Core.Core.TypeShape)">
<summary>
 Recognizes shapes that implement System.Collections.Generic.IEnumerable&lt;_&gt;
</summary>
</member>
<member name="M:TypeShape.Core.Core.Shape.|Collection|_|(TypeShape.Core.Core.TypeShape)">
<summary>
 Recognizes shapes that implement System.Collections.Generic.ICollection&lt;_&gt;
</summary>
</member>
<member name="M:TypeShape.Core.Core.Shape.|FSharpFunc|_|(TypeShape.Core.Core.TypeShape)">
<summary>
 Recognizes shapes of F# function types
</summary>
</member>
<member name="M:TypeShape.Core.Core.Shape.|FSharpMap|_|(TypeShape.Core.Core.TypeShape)">
<summary>
 Recognizes shapes of F# map types
</summary>
</member>
<member name="M:TypeShape.Core.Core.Shape.|FSharpSet|_|(TypeShape.Core.Core.TypeShape)">
<summary>
 Recognizes shapes of F# set types
</summary>
</member>
<member name="M:TypeShape.Core.Core.Shape.|FSharpRef|_|(TypeShape.Core.Core.TypeShape)">
<summary>
 Recognizes shapes of F# ref types
</summary>
</member>
<member name="M:TypeShape.Core.Core.Shape.|FSharpOption|_|(TypeShape.Core.Core.TypeShape)">
<summary>
 Recognizes shapes of F# option types
</summary>
</member>
<member name="M:TypeShape.Core.Core.Shape.|FSharpList|_|(TypeShape.Core.Core.TypeShape)">
<summary>
 Recognizes shapes of F# list types
</summary>
</member>
<member name="M:TypeShape.Core.Core.Shape.|Array|_|(TypeShape.Core.Core.TypeShape)">
<summary>
 Recognizes shapes that are .NET arrays
</summary>
</member>
<member name="M:TypeShape.Core.Core.Shape.|ISerializable|_|(TypeShape.Core.Core.TypeShape)">
<summary>
 Recognizes shapes that implement ISerializable
</summary>
</member>
<member name="M:TypeShape.Core.Core.Shape.|Exception|_|(TypeShape.Core.Core.TypeShape)">
<summary>
 Recognizes shapes that inherit from System.Exception
</summary>
</member>
<member name="M:TypeShape.Core.Core.Shape.|Delegate|_|(TypeShape.Core.Core.TypeShape)">
<summary>
 Recognizes shapes that inherit from System.Delegate
</summary>
</member>
<member name="M:TypeShape.Core.Core.Shape.|ResizeArray|_|(TypeShape.Core.Core.TypeShape)">
<summary>
 Recognizes shapes that are instances of System.Collections.Generic.List&lt;_&gt;
</summary>
</member>
<member name="M:TypeShape.Core.Core.Shape.|HashSet|_|(TypeShape.Core.Core.TypeShape)">
<summary>
 Recognizes shapes that are instances of System.Collections.Generic.HashSet&lt;_&gt;
</summary>
</member>
<member name="M:TypeShape.Core.Core.Shape.|Dictionary|_|(TypeShape.Core.Core.TypeShape)">
<summary>
 Recognizes shapes that are instances of System.Collections.Generic.Dictionary&lt;_,_&gt;
</summary>
</member>
<member name="M:TypeShape.Core.Core.Shape.|KeyValuePair|_|(TypeShape.Core.Core.TypeShape)">
<summary>
 Recognizes shapes that are instances of System.Collections.Generic.KeyValuePair&lt;_,_&gt;
</summary>
</member>
<member name="M:TypeShape.Core.Core.Shape.|DefaultConstructor|_|(TypeShape.Core.Core.TypeShape)">
<summary>
 Recognizes shapes that carry a parameterless constructor
</summary>
</member>
<member name="M:TypeShape.Core.Core.Shape.|Struct|NotStruct|Nullable|(TypeShape.Core.Core.TypeShape)">
<summary>
 Identifies whether shape satisfies the &apos;struct&apos;, &apos;not struct&apos; or &apos;nullable&apos; constraint
</summary>
</member>
<member name="M:TypeShape.Core.Core.Shape.|Comparison|_|(TypeShape.Core.Core.TypeShape)">
<summary>
 Recognizes any type that satisfies the F# `comparison` constraint
</summary>
</member>
<member name="M:TypeShape.Core.Core.Shape.|Equality|_|(TypeShape.Core.Core.TypeShape)">
<summary>
 Recognizes any type that satisfies the F# `equality` constraint
</summary>
</member>
<member name="M:TypeShape.Core.Core.Shape.|Enum|_|(TypeShape.Core.Core.TypeShape)">
<summary>
 Recognizes any type that is a .NET enumeration
</summary>
</member>
<member name="M:TypeShape.Core.Core.TypeShapeImpl.isInterfaceAssignableFrom(System.Type,System.Type)">
<summary>
 correctly resolves if type is assignable to interface
</summary>
</member>
<member name="T:TypeShape.Core.StagingExtensions.StagedGenerator2">
<summary>
 Rank-2 encoding of a generic staged computation
</summary>
</member>
<member name="T:TypeShape.Core.StagingExtensions.StagedGenerator1">
<summary>
 Rank-2 encoding of a generic staged computation
</summary>
</member>
<member name="M:TypeShape.Core.StagingExtensions.Expr.Y2(Microsoft.FSharp.Core.FSharpFunc{TypeShape.Core.StagingExtensions.StagedGenerator2,TypeShape.Core.StagingExtensions.StagedGenerator2})">
<summary>
 Y combinator implementation for a staged computation
</summary>
</member>
<member name="M:TypeShape.Core.StagingExtensions.Expr.Y1(Microsoft.FSharp.Core.FSharpFunc{TypeShape.Core.StagingExtensions.StagedGenerator1,TypeShape.Core.StagingExtensions.StagedGenerator1})">
<summary>
 Y combinator implementation for a staged computation
</summary>
</member>
<member name="M:TypeShape.Core.StagingExtensions.Expr.cleanup``1(Microsoft.FSharp.Quotations.FSharpExpr{``0})">
<summary>
 Optimizes away staging artifacts from expression tree
</summary>
</member>
<member name="M:TypeShape.Core.StagingExtensions.Expr.unlet``1(Microsoft.FSharp.Quotations.FSharpExpr{``0})">
<summary>
 Performs the transformation
 `let x = y in M[x]` =&gt; `M[y]` where y is a constant or variable.
</summary>
</member>
<member name="M:TypeShape.Core.StagingExtensions.Expr.unlambda``1(Microsoft.FSharp.Quotations.FSharpExpr{``0})">
<summary>
 traverses an expression tree applying the transformation
 `(fun x y z .. -&gt; M[x,y,z,..]) a b c =&gt; M[a,b,c,..]`,
 where a,b,c are variables or constants
</summary>
</member>
<member name="M:TypeShape.Core.StagingExtensions.Expr.switch``1(Microsoft.FSharp.Quotations.FSharpExpr{System.Int32},Microsoft.FSharp.Quotations.FSharpExpr{``0}[])">
<summary>
 expands a collection of expressions so that they
 branch according to the tag expression provided
</summary>
</member>
<member name="M:TypeShape.Core.StagingExtensions.Expr.update``1(System.String,Microsoft.FSharp.Quotations.FSharpExpr{``0},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Quotations.FSharpExpr{``0},Microsoft.FSharp.Quotations.FSharpExpr{``0}}[])">
<summary>
 Expands a collection of state-updating staged computations
 into a expression tree
</summary>
</member>
<member name="M:TypeShape.Core.StagingExtensions.Expr.fold``2(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Quotations.FSharpExpr{``0},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Quotations.FSharpExpr{``1},Microsoft.FSharp.Quotations.FSharpExpr{``0}}},System.String,Microsoft.FSharp.Quotations.FSharpExpr{``0},Microsoft.FSharp.Quotations.FSharpExpr{``1}[])">
<summary>
 Expands a collection of folding computations into a statically
 expanded expression tree
</summary>
</member>
<member name="M:TypeShape.Core.StagingExtensions.Expr.seq(Microsoft.FSharp.Quotations.FSharpExpr{Microsoft.FSharp.Core.Unit}[])">
<summary>
 expands a collection of computations
 into a sequenced expression
</summary>
</member>
<member name="M:TypeShape.Core.StagingExtensions.Expr.forall(Microsoft.FSharp.Quotations.FSharpExpr{System.Boolean}[])">
<summary>
 expands a collection of boolean expressions
 into a sequence of inlined &amp;&amp;&apos;s
</summary>
</member>
<member name="M:TypeShape.Core.StagingExtensions.Expr.lam3``4(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Quotations.FSharpExpr{``0},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Quotations.FSharpExpr{``1},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Quotations.FSharpExpr{``2},Microsoft.FSharp.Quotations.FSharpExpr{``3}}}})">
<summary>
 lambda abstraction for lifting staged expression computations
 into embeddable trees
</summary>
</member>
<member name="M:TypeShape.Core.StagingExtensions.Expr.lam2``3(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Quotations.FSharpExpr{``0},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Quotations.FSharpExpr{``1},Microsoft.FSharp.Quotations.FSharpExpr{``2}}})">
<summary>
 lambda abstraction for lifting staged expression computations
 into embeddable trees
</summary>
</member>
<member name="M:TypeShape.Core.StagingExtensions.Expr.lam``2(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Quotations.FSharpExpr{``0},Microsoft.FSharp.Quotations.FSharpExpr{``1}})">
<summary>
 lambda abstraction for lifting staged expression computations
 into embeddable trees
</summary>
</member>
<member name="M:TypeShape.Core.StagingExtensions.Expr.bindMutable``2(System.String,Microsoft.FSharp.Quotations.FSharpExpr{``0},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Quotations.FSharpExpr{``0},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Quotations.FSharpExpr{``0},Microsoft.FSharp.Quotations.FSharpExpr{Microsoft.FSharp.Core.Unit}},Microsoft.FSharp.Quotations.FSharpExpr{``1}}})">
 <summary>
     Staged bind combinator for mutable variables
 </summary>
 <param name="bname">Variable binding name.</param>
 <param name="bexpr">Bind expression.</param>
 <param name="cont">Continuation expression builder accepting a variable getter and setter.</param>
</member>
<member name="M:TypeShape.Core.StagingExtensions.Expr.bind``2(System.String,Microsoft.FSharp.Quotations.FSharpExpr{``0},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Quotations.FSharpExpr{``0},Microsoft.FSharp.Quotations.FSharpExpr{``1}})">
 <summary>
     Staged bind combinator
 </summary>
 <param name="bname">Variable binding name.</param>
 <param name="bexpr">Bind expression.</param>
 <param name="cont">Continuation expression builder.</param>
</member>
<member name="M:TypeShape.Core.StagingExtensions.Expr.cast``1(Microsoft.FSharp.Quotations.FSharpExpr)">
<summary>
 Converts an untyped expression into its typed counterpart
</summary>
</member>
<member name="M:TypeShape.Core.SubtypeExtensions.Shape.|SubtypeOf|_|``1(TypeShape.Core.Core.TypeShape{``0},TypeShape.Core.Core.TypeShape)">
<summary>
 Matches a shape whose type is a subtype of input shape
</summary>
</member>
<member name="M:TypeShape.Core.SubtypeExtensions.Shape.tryCreateSubtypeShape``1(TypeShape.Core.Core.TypeShape)">
<summary>
 Creates a subtype shape assuming that shape :&gt; &apos;TBase
</summary>
</member>
<member name="M:TypeShape.Core.Utils.ObjectCache.TryGetValue``1(System.Int64,``0@)">
<summary>
 Attempts to get cached value of given id
</summary>
</member>
<member name="M:TypeShape.Core.Utils.ObjectCache.Reset">
<summary>
 Resets state for cache instance
</summary>
</member>
<member name="M:TypeShape.Core.Utils.ObjectCache.HasValue(System.Int64)">
<summary>
 Returns true if cache has value for given id
</summary>
</member>
<member name="M:TypeShape.Core.Utils.ObjectCache.GetValue``1(System.Int64)">
<summary>
 Gets cached value of given id
</summary>
</member>
<member name="M:TypeShape.Core.Utils.ObjectCache.CreateUninitializedInstance``1(System.Int64,System.Type)">
<summary>
 Creates an uninitialized value for given id and 
 specified concrete type and appends it to the cache.
</summary>
</member>
<member name="M:TypeShape.Core.Utils.ObjectCache.AddValue``1(System.Int64,``0)">
<summary>
 Adds given value to cache or fixes up existing uninitialized object
 by performing a shallow copy on its fields.
</summary>
</member>
<member name="T:TypeShape.Core.Utils.ObjectCache">
<summary>
 Helper class for re-constructing cyclic object graphs
</summary>
</member>
<member name="P:TypeShape.Core.Utils.ObjectStack.ObjectId">
<summary>
 Id of the last object pushed to the stack
</summary>
</member>
<member name="P:TypeShape.Core.Utils.ObjectStack.IsFirstTime">
<summary>
 Indicates whether the last object was pushed to the stack for the first time
</summary>
</member>
<member name="P:TypeShape.Core.Utils.ObjectStack.IsCycle">
<summary>
 Indicates whether the current value already exists in the stack
</summary>
</member>
<member name="M:TypeShape.Core.Utils.ObjectStack.Reset">
<summary>
 Resets state for given stack instance
</summary>
</member>
<member name="T:TypeShape.Core.Utils.ObjectStack">
<summary>
 Helper class for detecting cycles in a traversed object graph
</summary>
</member>
<member name="M:TypeShape.Core.Utils.RecursiveValueHelper.ShallowCopy``1(``0,``0)">
<summary>
 performs a shallow copy of field contents from one object to another
</summary>
</member>
<member name="M:TypeShape.Core.Utils.RecursiveValueHelper.CreateUninitializedValue``1">
<summary>
 Creates an uninitialized value for given type
</summary>
</member>
<member name="T:TypeShape.Core.Utils.RecursiveValueHelper">
<summary>
 Helper methods used for constructing cyclic values
</summary>
</member>
<member name="P:TypeShape.Core.Utils.BinSearch.Values">
<summary>
 Gets the original input array used to form
 this binary search implementation
</summary>
</member>
<member name="M:TypeShape.Core.Utils.BinSearch.TryFindIndex(System.String)">
<summary>
 Returns an integer indicating the position of the
 given value in the source array, or -1 if not found.
</summary>
</member>
<member name="T:TypeShape.Core.Utils.BinSearch">
<summary>
 Provides a binary search implementation for string values
</summary>
</member>
<member name="P:TypeShape.Core.Utils.TypeCache.Values">
<summary>
 Gets all values registered in the cache
</summary>
</member>
<member name="P:TypeShape.Core.Utils.TypeCache.Keys">
<summary>
 Gets all types registered in the cache
</summary>
</member>
<member name="P:TypeShape.Core.Utils.TypeCache.Count">
<summary>
 Total number of items in cache
</summary>
</member>
<member name="M:TypeShape.Core.Utils.TypeCache.TryGetValue(System.Type,System.Object@)">
<summary>
 Try looking up cached value by type
</summary>
</member>
<member name="M:TypeShape.Core.Utils.TypeCache.TryGetValue``1(``0@)">
<summary>
 Try looking up cached value by type
</summary>
</member>
<member name="M:TypeShape.Core.Utils.TypeCache.TryFind(System.Type)">
<summary>
 Try looking up cached value by type
</summary>
</member>
<member name="M:TypeShape.Core.Utils.TypeCache.TryFind``1">
<summary>
 Try looking up cached value by type
</summary>
</member>
<member name="M:TypeShape.Core.Utils.TypeCache.Remove(System.Type)">
<summary>
 Removes given type and any dependencies from cache
 This will clean up any dependencies on that type too.
</summary>
</member>
<member name="M:TypeShape.Core.Utils.TypeCache.ForceAdd``1(``0)">
<summary>
 Forces update for value of given type
 This will clean up any dependencies on that type too.
</summary>
</member>
<member name="M:TypeShape.Core.Utils.TypeCache.CreateGenerationContext">
<summary>
 Creates a TypeGenerationContext that is bound to the current cache.
 Values generated by the manager can be committed back to the
 cache once completed.
</summary>
</member>
<member name="M:TypeShape.Core.Utils.TypeCache.ContainsKey(System.Type)">
<summary>
 Checks whether the supplied type is contained in cache
</summary>
</member>
<member name="M:TypeShape.Core.Utils.TypeCache.ContainsKey``1">
<summary>
 Checks whether the supplied type is contained in cache
</summary>
</member>
<member name="M:TypeShape.Core.Utils.TypeCache.Commit(TypeShape.Core.Utils.TypeGenerationContext)">
<summary>
 Commits the generates state by a completed TypeGenerationContext instance.
</summary>
</member>
<member name="M:TypeShape.Core.Utils.TypeCache.Clone">
<summary>
 Creates a clone of the current cache items
</summary>
</member>
<member name="T:TypeShape.Core.Utils.TypeCache">
<summary>
 Thread-safe cache of values indexed by type.
</summary>
</member>
<member name="M:TypeShape.Core.Utils.TypeGenerationContext.InitOrGetCachedValue``1(Microsoft.FSharp.Core.FSharpFunc{TypeShape.Core.Utils.Cell{``0},``0})">
 <summary>
     Registers an uninitialized value for given type or returns 
     a cached value if already computed.
 </summary>
 <param name="delay">Delay function used for defining recursive values.</param>
</member>
<member name="M:TypeShape.Core.Utils.TypeGenerationContext.Commit``1(TypeShape.Core.Utils.GenerationToken{``0},``0)">
<summary>
 Commits computed value to the generator.
</summary>
</member>
<member name="T:TypeShape.Core.Utils.TypeGenerationContext">
<summary>
 Helper class for generating recursive values
</summary>
</member>
<member name="T:TypeShape.Core.Utils.Cell`1">
<summary>
 Value container that will eventually be populated
</summary>
</member>
<member name="T:TypeShape.HKT.App`6">
<summary>
 HKT encoding that encapsulates an underlying materialized value.
</summary>
</member>
<member name="T:TypeShape.HKT.App`5">
<summary>
 HKT encoding that encapsulates an underlying materialized value.
</summary>
</member>
<member name="T:TypeShape.HKT.App`4">
<summary>
 HKT encoding that encapsulates an underlying materialized value.
</summary>
</member>
<member name="T:TypeShape.HKT.App`3">
<summary>
 HKT encoding that encapsulates an underlying materialized value.
</summary>
</member>
<member name="T:TypeShape.HKT.App`2">
<summary>
 HKT encoding that encapsulates an underlying materialized value.
</summary>
</member>
<member name="T:TypeShape.HKT.IFSharpTypeBuilder`2">
<summary>
 Composite Builder containig methods for common F# algebraic data types
</summary>
</member>
<member name="M:TypeShape.HKT.IPocoBuilder`2.Poco``1(TypeShape.Core.Core.ShapePoco{``0},TypeShape.HKT.App{`1,``0}[])">
<summary>
 Constructs a generic Poco HKT instance from shape metadata and extracted field instances
</summary>
</member>
<member name="M:TypeShape.HKT.ICliMutableBuilder`2.CliMutable``1(TypeShape.Core.Core.ShapeCliMutable{``0},TypeShape.HKT.App{`1,``0}[])">
<summary>
 Constructs a generic CliMutable HKT instance from shape metadata and extracted field instances
</summary>
</member>
<member name="M:TypeShape.HKT.IFSharpUnionBuilder`2.Union``1(TypeShape.Core.Core.ShapeFSharpUnion{``0},TypeShape.HKT.App{`1,``0}[][])">
<summary>
 Constructs a generic union HKT instance from shape metadata and extracted field instances
</summary>
</member>
<member name="M:TypeShape.HKT.IFSharpRecordBuilder`2.Record``1(TypeShape.Core.Core.ShapeFSharpRecord{``0},TypeShape.HKT.App{`1,``0}[])">
<summary>
 Constructs a generic F# record HKT instance from shape metadata and extracted field instances
</summary>
</member>
<member name="M:TypeShape.HKT.ITupleBuilder`2.Tuple``1(TypeShape.Core.Core.ShapeTuple{``0},TypeShape.HKT.App{`1,``0}[])">
<summary>
 Constructs a generic tuple HKT instance from shape metadata and extracted field instances
</summary>
</member>
<member name="T:TypeShape.HKT.IFieldExtractor`2">
<summary>
 Helper interface used for extracting generic programs from fields of record types
 Given a type &apos;t and a field of type &apos;f, the interface converts a HKT instance of
 type App&lt;&apos;F, &apos;field&gt; into an instance of App&lt;&apos;G, &apos;t&gt;. The return type hides type information
 for the field, but it might use a different HKT representation.
</summary>
</member>
<member name="M:TypeShape.HKT.IDelayBuilder`1.Delay``1(TypeShape.Core.Utils.Cell{TypeShape.HKT.App{`0,``0}})">
<summary>
 Bootstrap generic programs for recursive types
</summary>
</member>
<member name="T:TypeShape.HKT.IGenericProgram`1">
<summary>
 Generic program interface implementation
</summary>
</member>
<member name="M:TypeShape.HKT.IFoldContext`1.Fold``1(TypeShape.HKT.IGenericProgram{`0})">
<summary>
 Fold an instance for supplied type, given a `self` instance for resolving type dependencies
</summary>
</member>
<member name="T:TypeShape.HKT.IFoldContext`1">
<summary>
 Generic program folding context
</summary>
</member>
<member name="M:TypeShape.HKT.HKT.|Unpackss|``4(System.Collections.Generic.IEnumerable{``0})">
<summary>
 Unpacks a sequence of sequences of encoded HKT instance into its materialized value.
 Requires that the brand type &apos;F contains a static method Assign : App&lt;&apos;F, &apos;a&gt; * &apos;Fa -&gt; unit,
 so that the compiler can infer the association between encoded HKT and materialized type.
</summary>
</member>
<member name="M:TypeShape.HKT.HKT.|Unpacks|``3(System.Collections.Generic.IEnumerable{TypeShape.HKT.App{``0,``1}})">
<summary>
 Unpacks a sequence of encoded HKT instance into its materialized value.
 Requires that the brand type &apos;F contains a static method Assign : App&lt;&apos;F, &apos;a&gt; * &apos;Fa -&gt; unit,
 so that the compiler can infer the association between encoded HKT and materialized type.
</summary>
</member>
<member name="M:TypeShape.HKT.HKT.|Unpack|``3(TypeShape.HKT.App{``0,``1})">
<summary>
 Unpacks an encoded HKT instance into its materialized value.
 Requires that the brand type &apos;F contains a static method Assign : App&lt;&apos;F, &apos;a&gt; * &apos;Fa -&gt; unit,
 so that the compiler can infer the association between encoded HKT and materialized type.
</summary>
</member>
<member name="M:TypeShape.HKT.HKT.unpack``3(TypeShape.HKT.App{``0,``1})">
<summary>
 Unpacks an encoded HKT instance into its materialized value.
 Requires that the brand type &apos;F contains a static method Assign : App&lt;&apos;F, &apos;a&gt; * &apos;Fa -&gt; unit,
 so that the compiler can infer the association between encoded HKT and materialized type.
</summary>
</member>
<member name="M:TypeShape.HKT.HKT.pack``3(``0)">
<summary>
 Packs a materialized value into an encoded HKT instance.
 Requires that the brand type &apos;F contains a static method Assign : App&lt;&apos;F, &apos;a&gt; * &apos;Fa -&gt; unit,
 so that the compiler can infer the association between encoded HKT and materialized type.
</summary>
</member>
<member name="T:TypeShape.HKT.Fold">
<summary>
 TypeShape-driven generic program folding 
</summary>
</member>
<member name="M:TypeShape.HKT.FoldContext.fold``2(Microsoft.FSharp.Core.FSharpOption{TypeShape.Core.Utils.TypeCache},TypeShape.HKT.IFoldContext{``0})">
<summary>
 Builds a generic program using supplied folding context.
 Folding is performed recursively. Optionally accepts a cache instance for storing generated programs.
</summary>
</member>
<member name="M:TypeShape.Generic.collect``4(Microsoft.FSharp.Core.FSharpFunc{``0,``1},``3)">
 <summary>
 Generic collect combinator. Accumulates a collection of values based on mappings
 of instances of type 'a structurally within the source of type 'T following
 depth-first traversal. Cyclic objects are supported.
 </summary>
 <param name="mapping">Mapping function for collectable values.</param>
 <param name="source">Source type to traverse.</param>
</member>
<member name="M:TypeShape.Generic.exists``2(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},``1)">
 <summary>
 Generic exists combinator. Returns true iff at least one instance of type 'a
 structurally within the source 'T satisfies the user-provided predicate.
 </summary>
 <param name="predicate">Exists predicate.</param>
 <param name="source">Source type to traverse.</param>
</member>
<member name="M:TypeShape.Generic.forall``2(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},``1)">
 <summary>
 Generic forall combinator. Returns true iff all instances of type 'a
 structurally within the source 'T satisfy the user-provided predicate.
 </summary>
 <param name="predicate">Forall predicate.</param>
 <param name="source">Source type to traverse.</param>
</member>
<member name="M:TypeShape.Generic.sumBy``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},``2)">
 <summary>
 Generic sumBy combinator. Sums instances of type 'a structurally within the source
 type 'T following depth-first traversal. Cyclic objects are supported.
 </summary>
 <param name="projection">Projection function to sum by.</param>
 <param name="source">Source type to traverse.</param>
</member>
<member name="M:TypeShape.Generic.fold``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``0}},``0,``2)">
 <summary>
 Generic fold combinator. Folds over instances of type 'a structurally within
 the source type 'T following depth-first traversal. Cyclic objects are supported.
 </summary>
 <param name="folder">Folding function for instances of type 'a.</param>
 <param name="state">Initial state for the fold operation.</param>
 <param name="source">Source type to traverse.</param>
</member>
<member name="M:TypeShape.Generic.iterCancellation``2(Microsoft.FSharp.Core.FSharpFunc{System.Threading.CancellationTokenSource,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.Unit}},``1)">
 <summary>
 Generic iter combinator with cancellatoin semantics. Calls the action function on every instance
 of type 'a structurally wihtin the source type 'T using depth-first
 traversal. Cyclic objects are supported.
 </summary>
 <param name="action">Action to perform on every instance of type 'a.</param>
 <param name="source">Source type to be traversed for instances of type 'a.</param>
</member>
<member name="M:TypeShape.Generic.iter``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.Unit},``1)">
 <summary>
 Generic iter combinator. Calls the action function on every instance
 of type 'a structurally wihtin the source type 'T using depth-first
 traversal. Cyclic objects are supported.
 </summary>
 <param name="action">Action to perform on every instance of type 'a.</param>
 <param name="source">Source type to be traversed for instances of type 'a.</param>
</member>
<member name="M:TypeShape.Generic.map``2(Microsoft.FSharp.Core.FSharpFunc{``0,``0},``1)">
 <summary>
 Generic map combinator. Calls the mapper function on every instance
 of type 'a structurally within the source type 'T using depth-first
 traversal. Cyclic objects are supported.
 </summary>
 <param name="mapper">Mapping operation to perform on every instance of type 'a.</param>
 <param name="source">Source type to be traversed for instances of type 'a.</param>
</member>
<member name="M:TypeShape.Empty.notEmpty``1">
<summary>
 Generates a structural empty value that populates
 variadic types with singletons
</summary>
</member>
<member name="M:TypeShape.Empty.empty``1">
<summary>
 Generates a structural empty value for given type
</summary>
</member>
<member name="M:TypeShape.Empty.register``1(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,``0})">
<summary>
 Registers an empty factory for a given type
</summary>
</member>
<member name="M:TypeShape.UnionContract.UnionContractEncoder.Create``2(TypeShape.UnionContract.IEncoder{``1},Microsoft.FSharp.Core.FSharpOption{System.Boolean},Microsoft.FSharp.Core.FSharpOption{System.Boolean})">
 <summary>
     Given a primite object encoder instance, generates
     an F# union encoder that constructs and deconstructs
     DU instances into a flat structure. By default, all union cases must
     contain exactly one field.
 </summary>
 <param name="encoder">Encoder used for converting union case payloads into given 'Format.</param>
 <param name="requireRecordFields">Fail encoder generation if union cases contain fields that are not F# records. Defaults to false.</param>
 <param name="allowNullaryCases">Fail encoder generation if union contains nullary cases. Defaults to true.</param>
</member>
<member name="M:TypeShape.UnionContract.UnionContractEncoder`2.TryDecode(TypeShape.UnionContract.EncodedUnion{`1})">
<summary>
 Decodes a formatted representation into a union instance. Does not throw exception on format mismatches
</summary>
</member>
<member name="M:TypeShape.UnionContract.UnionContractEncoder`2.GetCaseName(`0)">
<summary>
 Gets the union case string identifier for given union instance
</summary>
</member>
<member name="M:TypeShape.UnionContract.UnionContractEncoder`2.Encode(`0)">
<summary>
 Encodes a union instance into a decoded representation
</summary>
</member>
<member name="M:TypeShape.UnionContract.UnionContractEncoder`2.Decode(TypeShape.UnionContract.EncodedUnion{`1})">
<summary>
 Decodes a formatted representation into a union instance. Can potentially throw FormatException
</summary>
</member>
<member name="T:TypeShape.UnionContract.UnionContractEncoder`2">
<summary>
 Provides an encoder implementation for a union of events
</summary>
</member>
<member name="T:TypeShape.UnionContract.EncodedUnion`1">
<summary>
 Represents an encoded union case
</summary>
</member>
<member name="T:TypeShape.UnionContract.BoxEncoder">
<summary>
 Generic encoder that simply upcasts values to System.Object
</summary>
</member>
<member name="P:TypeShape.UnionContract.IEncoder`1.Empty">
<summary>
 &apos;Null&apos; format value to be used for union cases without a payload
</summary>
</member>
<member name="M:TypeShape.UnionContract.IEncoder`1.Encode``1(``0)">
<summary>
 Encodes any value to the implementation format
</summary>
</member>
<member name="M:TypeShape.UnionContract.IEncoder`1.Decode``1(`0)">
<summary>
 Decodes format instance to any value
</summary>
</member>
<member name="T:TypeShape.UnionContract.IEncoder`1">
<summary>
 Generic encoding abstraction for serializing/deserializing
 to a fixed format type, e.g. string, byte[], Newtonsoft JsonValue etc
</summary>
</member>
<member name="T:TypeShape.UnionContract.IUnionContract">
<summary>
 Marker interface for tagging union contract types
 see the &lt;a href=&quot;https://eiriktsarpalis.wordpress.com/2018/10/30/a-contract-pattern-for-schemaless-datastores&quot;&gt;A Contract Pattern for Schemaless DataStores&lt;/a&gt; blog article for an overview
</summary>
</member>
<member name="M:TypeShape.UnionContract.Impl.mkUnionEncoder``2">
<summary>
 Generates an F# union encoder given a generic format encoder instance
</summary>
</member>
<member name="M:TypeShape.Sizeof.gsizeof``1(``0)">
<summary>
 Generic size calculator for arbitrary object graphs.
 NB this does not denote actual memory size, it simply
 provides a size metric that loosely corresponds to bytes.
</summary>
</member>
<member name="T:TypeShape.Sizeof">
<summary>
 Generic sizeof operator
</summary>
</member>
<member name="M:TypeShape.Clone.clone``1(``0)">
<summary>
 Creates a deep clone for the provided value.
 Accounts for reference equality and object cycles.
</summary>
</member>
</members>
</doc>
