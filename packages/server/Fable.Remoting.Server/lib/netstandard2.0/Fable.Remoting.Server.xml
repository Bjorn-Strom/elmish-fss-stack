<?xml version="1.0" encoding="utf-8"?>
<doc>
<assembly><name>Fable.Remoting.Server</name></assembly>
<members>
<member name="P:TypeShape.ShapePoco`1.Properties">
<summary>
 Property shapes for the type
</summary>
</member>
<member name="P:TypeShape.ShapePoco`1.IsStruct">
<summary>
 True iff POCO is a struct
</summary>
</member>
<member name="P:TypeShape.ShapePoco`1.IsCSharpRecord">
<summary>
 True iff POCO is a C# 9 record
</summary>
</member>
<member name="P:TypeShape.ShapePoco`1.Fields">
<summary>
 Field shapes for the type
</summary>
</member>
<member name="P:TypeShape.ShapePoco`1.Constructors">
<summary>
 Constructor shapes for the type
</summary>
</member>
<member name="M:TypeShape.ShapePoco`1.CreateUninitialized">
<summary>
 Creates an uninitialized instance for POCO
</summary>
</member>
<member name="T:TypeShape.ShapePoco`1">
<summary>
 Denotes any .NET type that is either a class or a struct
</summary>
</member>
<member name="P:TypeShape.IShapePoco.Properties">
<summary>
 Property shapes for the type
</summary>
</member>
<member name="P:TypeShape.IShapePoco.IsStruct">
<summary>
 True iff POCO is a struct
</summary>
</member>
<member name="P:TypeShape.IShapePoco.IsCSharpRecord">
<summary>
 True iff POCO is a C# 9 record
</summary>
</member>
<member name="P:TypeShape.IShapePoco.Fields">
<summary>
 Field shapes for the type
</summary>
</member>
<member name="P:TypeShape.IShapePoco.Constructors">
<summary>
 Constructor shapes for the type
</summary>
</member>
<member name="T:TypeShape.IShapePoco">
<summary>
 Denotes any .NET type that is either a class or a struct
</summary>
</member>
<member name="P:TypeShape.ShapeCliMutable`1.Properties">
<summary>
 Property shapes for C# record
</summary>
</member>
<member name="P:TypeShape.ShapeCliMutable`1.DefaultCtorInfo">
<summary>
 Gets the default constructor info defined in the type
</summary>
</member>
<member name="M:TypeShape.ShapeCliMutable`1.CreateUninitialized">
<summary>
 Creates an uninitialized instance for given C# record
</summary>
</member>
<member name="T:TypeShape.ShapeCliMutable`1">
<summary>
 Denotes a type that behaves like a C# record:
 Carries a parameterless constructor and settable properties
</summary>
</member>
<member name="P:TypeShape.IShapeCliMutable.Properties">
<summary>
 Gettable and Settable properties for C# DTO
</summary>
</member>
<member name="T:TypeShape.IShapeCliMutable">
<summary>
 Denotes a type that behaves like a mutable C# DTO:
 Carries a parameterless constructor and settable properties
</summary>
</member>
<member name="P:TypeShape.ShapeFSharpUnion`1.UnionCases">
<summary>
 Case shapes for given union type
</summary>
</member>
<member name="M:TypeShape.ShapeFSharpUnion`1.GetTag(System.String)">
<summary>
 Gets the underlying tag id for given union case name
</summary>
</member>
<member name="M:TypeShape.ShapeFSharpUnion`1.GetTag(`0)">
<summary>
 Gets the underlying tag id for given union instance
</summary>
</member>
<member name="T:TypeShape.ShapeFSharpUnion`1">
<summary>
 Denotes an F# Union shape
</summary>
</member>
<member name="P:TypeShape.IShapeFSharpUnion.UnionCases">
<summary>
 Case shapes for given union type
</summary>
</member>
<member name="T:TypeShape.IShapeFSharpUnion">
<summary>
 Denotes an F# Union shape
</summary>
</member>
<member name="P:TypeShape.ShapeFSharpUnionCase`1.Fields">
<summary>
 Field shapes for union case
</summary>
</member>
<member name="P:TypeShape.ShapeFSharpUnionCase`1.CaseInfo">
<summary>
 Underlying FSharp.Reflection.UnionCaseInfo description
</summary>
</member>
<member name="P:TypeShape.ShapeFSharpUnionCase`1.Arity">
<summary>
 Number of fields in the particular union case
</summary>
</member>
<member name="M:TypeShape.ShapeFSharpUnionCase`1.CreateUninitialized">
<summary>
 Creates an uninitialized instance for specific union case
</summary>
</member>
<member name="T:TypeShape.ShapeFSharpUnionCase`1">
<summary>
 Denotes an F# union case shape
</summary>
</member>
<member name="P:TypeShape.IShapeFSharpUnionCase.Fields">
<summary>
 Field shapes for union case
</summary>
</member>
<member name="P:TypeShape.IShapeFSharpUnionCase.CaseInfo">
<summary>
 Underlying FSharp.Reflection.UnionCaseInfo description
</summary>
</member>
<member name="T:TypeShape.IShapeFSharpUnionCase">
<summary>
 Denotes an F# union case shape
</summary>
</member>
<member name="P:TypeShape.ShapeFSharpRecord`1.IsStructRecord">
<summary>
 True if an F# struct record
</summary>
</member>
<member name="P:TypeShape.ShapeFSharpRecord`1.IsAnonymousRecord">
<summary>
 True if F# 4.6 anonyous records
</summary>
</member>
<member name="P:TypeShape.ShapeFSharpRecord`1.Fields">
<summary>
 F# record field shapes
</summary>
</member>
<member name="M:TypeShape.ShapeFSharpRecord`1.CreateUninitialized">
<summary>
 Creates an uninitialized instance for given record
</summary>
</member>
<member name="T:TypeShape.ShapeFSharpRecord`1">
<summary>
 Identifies an F# record type
</summary>
</member>
<member name="P:TypeShape.IShapeFSharpRecord.Fields">
<summary>
 F# record field shapes
</summary>
</member>
<member name="T:TypeShape.IShapeFSharpRecord">
<summary>
 Denotes an F# record type
</summary>
</member>
<member name="P:TypeShape.ShapeTuple`1.Elements">
<summary>
 Tuple element shape definitions
</summary>
</member>
<member name="M:TypeShape.ShapeTuple`1.CreateUninitialized">
<summary>
 Creates an uninitialized tuple instance of given type
</summary>
</member>
<member name="T:TypeShape.ShapeTuple`1">
<summary>
 Identifies a specific System.Tuple shape
</summary>
</member>
<member name="P:TypeShape.IShapeTuple.Elements">
<summary>
 Tuple element shape definitions
</summary>
</member>
<member name="T:TypeShape.IShapeTuple">
<summary>
 Denotes a specific System.Tuple shape
</summary>
</member>
<member name="M:TypeShape.ShapeConstructor`2.Invoke(`1)">
<summary>
 Creates an instance of declaring type with supplied constructor args
</summary>
</member>
<member name="T:TypeShape.ShapeConstructor`2">
<summary>
 Identifies a constructor implementation shape
</summary>
</member>
<member name="T:TypeShape.IShapeConstructor`1">
<summary>
 Identifies a constructor implementation shape
</summary>
</member>
<member name="P:TypeShape.IShapeConstructor.IsPublic">
<summary>
 Denotes whether constructor is public
</summary>
</member>
<member name="P:TypeShape.IShapeConstructor.ConstructorInfo">
<summary>
 ConstructorInfo instance
</summary>
</member>
<member name="P:TypeShape.IShapeConstructor.Arity">
<summary>
 Denotes the arity of the constructor arguments
</summary>
</member>
<member name="T:TypeShape.IShapeConstructor">
<summary>
 Identifies a constructor implementation shape
</summary>
</member>
<member name="M:TypeShape.ShapeMember`2.Set(`0,`1)">
<summary>
 Assigns value to the provided instance. NB this is a mutating operation
</summary>
</member>
<member name="M:TypeShape.ShapeMember`2.Inject(`0,`1)">
<summary>
 Assigns value to the provided instance. NB this is a mutating operation
</summary>
</member>
<member name="T:TypeShape.ShapeMember`2">
<summary>
 Identifies an instance member that defines
 a mutable value in a class instance, typically a field or property
</summary>
</member>
<member name="T:TypeShape.IShapeMember`1">
<summary>
 Identifies an instance member that defines
 a mutable value in a class instance, typically a field or property
</summary>
</member>
<member name="P:TypeShape.ReadOnlyMember`2.MemberInfo">
<summary>
 The actual System.Reflection.MemberInfo corresponding to member
</summary>
</member>
<member name="P:TypeShape.ReadOnlyMember`2.Label">
<summary>
 Human-readable member identifier
</summary>
</member>
<member name="P:TypeShape.ReadOnlyMember`2.IsStructMember">
<summary>
 True iff member is contained within a struct
</summary>
</member>
<member name="P:TypeShape.ReadOnlyMember`2.IsPublic">
<summary>
 True iff member is public
</summary>
</member>
<member name="M:TypeShape.ReadOnlyMember`2.Project(`0)">
<summary>
 Gets the current value from the given declaring type instance
</summary>
</member>
<member name="M:TypeShape.ReadOnlyMember`2.Get(`0)">
<summary>
 Gets the current value from the given declaring type instance
</summary>
</member>
<member name="T:TypeShape.ReadOnlyMember`2">
<summary>
 Identifies an instance member that defines a read-only value
 in a class instance, typically a field or property
</summary>
</member>
<member name="T:TypeShape.IShapeReadOnlyMember`1">
<summary>
 Identifies an instance member that defines a read-only value
 in a class instance, typically a field or property
</summary>
</member>
<member name="P:TypeShape.IShapeReadOnlyMember.MemberInfo">
<summary>
 The actual System.Reflection.MemberInfo corresponding to member
</summary>
</member>
<member name="P:TypeShape.IShapeReadOnlyMember.Member">
<summary>
 Type of value stored by member
</summary>
</member>
<member name="P:TypeShape.IShapeReadOnlyMember.Label">
<summary>
 Human-readable member identifier
</summary>
</member>
<member name="P:TypeShape.IShapeReadOnlyMember.IsStructMember">
<summary>
 True iff member is contained within a struct
</summary>
</member>
<member name="P:TypeShape.IShapeReadOnlyMember.IsPublic">
<summary>
 True iff member is public
</summary>
</member>
<member name="T:TypeShape.IShapeReadOnlyMember">
<summary>
 Identifies an instance member that defines a read-only value
 in a class instance, typically a field or property
</summary>
</member>
<member name="P:TypeShape.IShapeArray.Rank">
<summary>
 Gets the rank of the array type shape
</summary>
</member>
<member name="T:TypeShape.TypeShape`1">
<summary>
 Encapsulates a type variable that can be accessed using type shape visitors
</summary>
</member>
<member name="M:TypeShape.TypeShape.FromValue(System.Object)">
 <summary>
     Creates a type shape instance from the underlying
     type of a given value.
 </summary>
 <param name="obj">Non-null value to extract shape data from.</param>
</member>
<member name="M:TypeShape.TypeShape.Create``1">
 <summary>
     Creates a type shape instance for given type
 </summary>
</member>
<member name="M:TypeShape.TypeShape.Create(System.Type)">
 <summary>
     Creates a type shape instance for given type
 </summary>
 <param name="typ">System.Type to be resolved.</param>
</member>
<member name="T:TypeShape.TypeShape">
<summary>
 Encapsulates a type variable that can be accessed using type shape visitors
</summary>
</member>
<member name="T:TypeShape.ITypeVisitor`1">
<summary>
 Used to extract the type variable contained in a specific shape
</summary>
</member>
<member name="T:TypeShape.TypeShapeInfo">
<summary>
 Provides a simple breakdown of basic kinds of types.
 Used for easier extraction of type shapes in the active pattern implementations.
</summary>
</member>
<member name="M:TypeShape.shapeof``1">
<summary>
 Creates a type shape instance for given type
</summary>
</member>
<member name="M:TypeShape.Type.IsInterfaceAssignableFrom(System.Type,System.Type)">
<summary>
 Correctly resolves if type is assignable to interface
</summary>
</member>
<member name="M:TypeShape.Activator.CreateInstanceGeneric.Static``1(Microsoft.FSharp.Core.FSharpOption{System.Type[]},Microsoft.FSharp.Core.FSharpOption{System.Object[]})">
<summary>
 Generic edition of the activator method which support type parameters and private types
</summary>
</member>
<member name="M:TypeShape.Shape.|Poco|_|(TypeShape.TypeShape)">
<summary>
 Recognizes POCO shapes, .NET types that are either classes, structs or C# records types
</summary>
</member>
<member name="M:TypeShape.Shape.|CliMutable|_|(TypeShape.TypeShape)">
<summary>
 Recognizes shapes that look like C# record classes
 They are classes with parameterless constructors and settable properties
</summary>
</member>
<member name="M:TypeShape.Shape.|Tuple|_|(TypeShape.TypeShape)">
<summary>
 Recognizes shapes that are System.Tuple instances of arbitrary arity
</summary>
</member>
<member name="M:TypeShape.Shape.|FSharpUnion|_|(TypeShape.TypeShape)">
<summary>
 Recognizes shapes that are F# unions
</summary>
</member>
<member name="M:TypeShape.Shape.|FSharpRecord|_|(TypeShape.TypeShape)">
<summary>
 Recognizes shapes that are F# records
</summary>
</member>
<member name="M:TypeShape.Shape.|Enumerable|_|(TypeShape.TypeShape)">
<summary>
 Recognizes shapes that implement System.Collections.Generic.IEnumerable&lt;_&gt;
</summary>
</member>
<member name="M:TypeShape.Shape.|Collection|_|(TypeShape.TypeShape)">
<summary>
 Recognizes shapes that implement System.Collections.Generic.ICollection&lt;_&gt;
</summary>
</member>
<member name="M:TypeShape.Shape.|FSharpFunc|_|(TypeShape.TypeShape)">
<summary>
 Recognizes shapes of F# function types
</summary>
</member>
<member name="M:TypeShape.Shape.|FSharpMap|_|(TypeShape.TypeShape)">
<summary>
 Recognizes shapes of F# map types
</summary>
</member>
<member name="M:TypeShape.Shape.|FSharpSet|_|(TypeShape.TypeShape)">
<summary>
 Recognizes shapes of F# set types
</summary>
</member>
<member name="M:TypeShape.Shape.|FSharpRef|_|(TypeShape.TypeShape)">
<summary>
 Recognizes shapes of F# ref types
</summary>
</member>
<member name="M:TypeShape.Shape.|FSharpOption|_|(TypeShape.TypeShape)">
<summary>
 Recognizes shapes of F# option types
</summary>
</member>
<member name="M:TypeShape.Shape.|FSharpList|_|(TypeShape.TypeShape)">
<summary>
 Recognizes shapes of F# list types
</summary>
</member>
<member name="M:TypeShape.Shape.|Array|_|(TypeShape.TypeShape)">
<summary>
 Recognizes shapes that are .NET arrays
</summary>
</member>
<member name="M:TypeShape.Shape.|ISerializable|_|(TypeShape.TypeShape)">
<summary>
 Recognizes shapes that implement ISerializable
</summary>
</member>
<member name="M:TypeShape.Shape.|Exception|_|(TypeShape.TypeShape)">
<summary>
 Recognizes shapes that inherit from System.Exception
</summary>
</member>
<member name="M:TypeShape.Shape.|Delegate|_|(TypeShape.TypeShape)">
<summary>
 Recognizes shapes that inherit from System.Delegate
</summary>
</member>
<member name="M:TypeShape.Shape.|ResizeArray|_|(TypeShape.TypeShape)">
<summary>
 Recognizes shapes that are instances of System.Collections.Generic.List&lt;_&gt;
</summary>
</member>
<member name="M:TypeShape.Shape.|HashSet|_|(TypeShape.TypeShape)">
<summary>
 Recognizes shapes that are instances of System.Collections.Generic.HashSet&lt;_&gt;
</summary>
</member>
<member name="M:TypeShape.Shape.|Dictionary|_|(TypeShape.TypeShape)">
<summary>
 Recognizes shapes that are instances of System.Collections.Generic.Dictionary&lt;_,_&gt;
</summary>
</member>
<member name="M:TypeShape.Shape.|KeyValuePair|_|(TypeShape.TypeShape)">
<summary>
 Recognizes shapes that are instances of System.Collections.Generic.KeyValuePair&lt;_,_&gt;
</summary>
</member>
<member name="M:TypeShape.Shape.|DefaultConstructor|_|(TypeShape.TypeShape)">
<summary>
 Recognizes shapes that carry a parameterless constructor
</summary>
</member>
<member name="M:TypeShape.Shape.|Struct|NotStruct|Nullable|(TypeShape.TypeShape)">
<summary>
 Identifies whether shape satisfies the &apos;struct&apos;, &apos;not struct&apos; or &apos;nullable&apos; constraint
</summary>
</member>
<member name="M:TypeShape.Shape.|Comparison|_|(TypeShape.TypeShape)">
<summary>
 Recognizes any type that satisfies the F# `comparison` constraint
</summary>
</member>
<member name="M:TypeShape.Shape.|Equality|_|(TypeShape.TypeShape)">
<summary>
 Recognizes any type that satisfies the F# `equality` constraint
</summary>
</member>
<member name="M:TypeShape.Shape.|Enum|_|(TypeShape.TypeShape)">
<summary>
 Recognizes any type that is a .NET enumeration
</summary>
</member>
<member name="M:TypeShape.TypeShapeImpl.isInterfaceAssignableFrom(System.Type,System.Type)">
<summary>
 correctly resolves if type is assignable to interface
</summary>
</member>
<member name="T:Fable.Remoting.Server.Documentation">
<summary>
 Contains documented routes for an API
</summary>
</member>
<member name="P:Fable.Remoting.Server.RouteDocs.Examples">
<summary>
 Examples are objects and optionally, their description
</summary>
</member>
<member name="P:Fable.Remoting.Server.RouteDocs.Description">
<summary>
 The description of the method
</summary>
</member>
<member name="P:Fable.Remoting.Server.RouteDocs.Alias">
<summary>
 An alias for the method name
</summary>
</member>
<member name="T:Fable.Remoting.Server.ProtocolImplementation`2">
<summary>
 A protocol implementation can be a static value provided or it can be generated from the Http context on every request.
</summary>
</member>
<member name="T:Fable.Remoting.Server.ErrorResult">
<summary>
 The ErrorResult lets you choose whether you want to propagate a custom error back to the client or to ignore it. Either case, an exception is thrown on the call-site from the client
</summary>
</member>
<member name="T:Fable.Remoting.Server.RouteInfo`1">
<summary>
 Route information that is propagated to error handler when exceptions are thrown
</summary>
</member>
<member name="M:Fable.Remoting.Server.ApiDocs`1.route``2(Microsoft.FSharp.Quotations.FSharpExpr{Microsoft.FSharp.Core.FSharpFunc{`0,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{``1}}}})">
<summary>
 Document a route
</summary>
</member>
<member name="M:Fable.Remoting.Server.ApiDocs`1.route``1(Microsoft.FSharp.Quotations.FSharpExpr{Microsoft.FSharp.Core.FSharpFunc{`0,Microsoft.FSharp.Control.FSharpAsync{``0}}})">
<summary>
 Document a route
</summary>
</member>
<member name="M:Fable.Remoting.Server.ApiDocs`1.example``1(Microsoft.FSharp.Quotations.FSharpExpr{Microsoft.FSharp.Core.FSharpFunc{`0,Microsoft.FSharp.Control.FSharpAsync{``0}}},Fable.Remoting.Server.RouteDocs)">
<summary>
 Adds example to the route definition form the way you would use the remote function
</summary>
</member>
<member name="M:Fable.Remoting.Server.ApiDocs`1.description(System.String,Fable.Remoting.Server.RouteDocs)">
<summary>
 Adds a description to the route definition
</summary>
</member>
<member name="M:Fable.Remoting.Server.ApiDocs`1.alias(System.String,Fable.Remoting.Server.RouteDocs)">
<summary>
 Add human-friendly alias for the remote function name
</summary>
</member>
<member name="T:Fable.Remoting.Server.ApiDocs`1">
<summary>
 Helper class that constructs documented routes
</summary>
</member>
<member name="M:Fable.Remoting.Server.Diagnostics.outputPhase(Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpFunc{System.String,Microsoft.FSharp.Core.Unit}},System.String)">
<summary>
 Logs the serialized output from the server
</summary>
</member>
<member name="M:Fable.Remoting.Server.Diagnostics.deserializationPhase(Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpFunc{System.String,Microsoft.FSharp.Core.Unit}},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,System.String},System.Type[])">
<summary>
 Logs the JSON input and the corresponding types that the JSON will be converter into. 
</summary>
</member>
<member name="M:Fable.Remoting.Server.Diagnostics.typePrinter(System.Type)">
<summary>
 Simplifes the name of the type that is to be deserialized 
</summary>
</member>
<member name="M:Fable.Remoting.Server.Remoting.fromValue``2(``0,Fable.Remoting.Server.RemotingOptions{``1,``0})">
<summary>
 Builds the API using the provided static protocol implementation 
</summary>
</member>
<member name="M:Fable.Remoting.Server.Remoting.fromContext``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Fable.Remoting.Server.RemotingOptions{``0,``1})">
<summary>
 Builds the API using a function that takes the incoming Http context and returns a protocol implementation. You can use the Http context to read information about the incoming request and also use the Http context to resolve dependencies using the underlying dependency injection mechanism.
</summary>
</member>
<member name="M:Fable.Remoting.Server.Remoting.withBinarySerialization``2(Fable.Remoting.Server.RemotingOptions{``0,``1})">
<summary>
 Specifies that the API only uses binary serialization
</summary>
</member>
<member name="M:Fable.Remoting.Server.Remoting.withErrorHandler``2(Microsoft.FSharp.Core.FSharpFunc{System.Exception,Microsoft.FSharp.Core.FSharpFunc{Fable.Remoting.Server.RouteInfo{``0},Fable.Remoting.Server.ErrorResult}},Fable.Remoting.Server.RemotingOptions{``0,``1})">
<summary>
 Ennables you to define a custom error handler for unhandled exceptions thrown by your remote functions. It can also be used for logging purposes or if you wanted to propagate errors back to client.
</summary>
</member>
<member name="M:Fable.Remoting.Server.Remoting.withDocs``2(System.String,Fable.Remoting.Server.Documentation,Fable.Remoting.Server.RemotingOptions{``0,``1})">
<summary>
 Enables the automatic generation of API documentation based on type-metadata 
</summary>
</member>
<member name="M:Fable.Remoting.Server.Remoting.withDiagnosticsLogger``2(Microsoft.FSharp.Core.FSharpFunc{System.String,Microsoft.FSharp.Core.Unit},Fable.Remoting.Server.RemotingOptions{``0,``1})">
<summary>
 Enables the diagnostics logger that will log what steps the library is taking when a request comes in. This could help troubleshoot serialization issues but it could be also be interesting to see what is going on under the hood.
</summary>
</member>
<member name="M:Fable.Remoting.Server.Remoting.withRouteBuilder``2(Microsoft.FSharp.Core.FSharpFunc{System.String,Microsoft.FSharp.Core.FSharpFunc{System.String,System.String}},Fable.Remoting.Server.RemotingOptions{``0,``1})">
<summary>
 Defines how routes are built using the type name and method name. By default, the generated routes are of the form `/typeName/methodName`.
</summary>
</member>
<member name="M:Fable.Remoting.Server.Remoting.createApi``2">
<summary>
 Starts with the default configuration for building an API 
</summary>
</member>
<member name="M:Fable.Remoting.Server.ThreadSafeCell.computeOnce``1(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,``0})">
<summary>
 Takes in an expensive synchronous function, runs it once and returns a function that retrieves the computed value asynchronously
</summary>
</member>
</members>
</doc>
