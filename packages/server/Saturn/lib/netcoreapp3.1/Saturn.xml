<?xml version="1.0" encoding="utf-8"?>
<doc>
<assembly><name>Saturn</name></assembly>
<members>
<member name="T:Saturn.Common">
<summary>
Module with some helper functions used in Saturn, mostly for internal usage
</summary>
</member>
<member name="P:Saturn.CORS.CORSConfig.maxAge">
<summary>
 Max age in seconds the user agent is allowed to cache the result of the request.
</summary>
</member>
<member name="P:Saturn.CORS.CORSConfig.exposeHeaders">
<summary>
 The list of response headers exposed to client. This is sent in AccessControlExposeHeaders header.
</summary>
</member>
<member name="P:Saturn.CORS.CORSConfig.allowCookies">
<summary>
 Allow cookies? This is sent in the AccessControlAllowCredentials header.
</summary>
</member>
<member name="P:Saturn.CORS.CORSConfig.allowedMethods">
<summary>
 The list of allowed HttpMethods for the request.
</summary>
</member>
<member name="P:Saturn.CORS.CORSConfig.allowedUris">
<summary>
 The list of allowed Uri(s) for requests.
</summary>
</member>
<member name="T:Saturn.CORS.CORSConfig">
<summary>
 The configuration values for CORS
</summary>
</member>
<member name="M:Saturn.CORS.cors(Saturn.CORS.CORSConfig,Microsoft.FSharp.Core.FSharpFunc{Microsoft.AspNetCore.Http.HttpContext,System.Threading.Tasks.Task{Microsoft.FSharp.Core.FSharpOption{Microsoft.AspNetCore.Http.HttpContext}}},Microsoft.AspNetCore.Http.HttpContext)">
<summary>
Check the incoming request against the provided `CORSConfig`.
</summary>
</member>
<member name="T:Saturn.CORS">
<summary>
Module defining CORS `HttpHandler`
</summary>
</member>
<member name="M:Saturn.CSRF.HttpContext.TryValidateCSRF(Microsoft.AspNetCore.Http.HttpContext)">
<summary>
 Protect a resource by validating that requests that can change state come with a valid request antiforgery token, which is based off of a known session token.
 The particular configuration options can be set via the `application` builder&apos;s `use_antiforgery_with_config` method.
 If the request is not valid, an Error result will be returned with details
</summary>
</member>
<member name="M:Saturn.CSRF.HttpContext.ValidateCSRF(Microsoft.AspNetCore.Http.HttpContext)">
<summary>
 Protect a resource by validating that requests that can change state come with a valid request antiforgery token, which is based off of a known session token.
 The particular configuration options can be set via the `application` builder&apos;s `use_antiforgery_with_config` method.
 If the request is not valid, an exception will be thrown with details
</summary>
</member>
<member name="P:Saturn.CSRF.csrf">
<summary>
 Protect a resource by validating that requests that can change state come with a valid request antiforgery token, which is based off of a known session token.
 The particular configuration options can be set via the `application` builder&apos;s `use_antiforgery_with_config` method.
</summary>
</member>
<member name="M:Saturn.CSRF.tryCsrf(Microsoft.FSharp.Core.FSharpFunc{Saturn.CSRF.CSRFError,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{Microsoft.AspNetCore.Http.HttpContext,System.Threading.Tasks.Task{Microsoft.FSharp.Core.FSharpOption{Microsoft.AspNetCore.Http.HttpContext}}},Microsoft.FSharp.Core.FSharpFunc{Microsoft.AspNetCore.Http.HttpContext,System.Threading.Tasks.Task{Microsoft.FSharp.Core.FSharpOption{Microsoft.AspNetCore.Http.HttpContext}}}}},Microsoft.FSharp.Core.FSharpFunc{Microsoft.AspNetCore.Http.HttpContext,System.Threading.Tasks.Task{Microsoft.FSharp.Core.FSharpOption{Microsoft.AspNetCore.Http.HttpContext}}},Microsoft.AspNetCore.Http.HttpContext)">
<summary>
 Protect a resource by validating that requests that can change state come with a valid request antiforgery token, which is based off of a known session token.
 The particular configuration options can be set via the `application` builder&apos;s `use_antiforgery_with_config` method.
 If the request is not valid, a custom error handler will be invoked with the validation error
</summary>
</member>
<member name="M:Saturn.CSRF.View.Giraffe.protectedForm(Microsoft.AspNetCore.Http.HttpContext,Microsoft.FSharp.Collections.FSharpList{Giraffe.GiraffeViewEngine.XmlAttribute},Microsoft.FSharp.Collections.FSharpList{Giraffe.GiraffeViewEngine.XmlNode})">
<summary>
View helper for creating a form that implicitly inserts a CSRF token hidden form input.
</summary>
</member>
<member name="M:Saturn.CSRF.View.Giraffe.csrfTokenInput(Microsoft.AspNetCore.Http.HttpContext)">
<summary>
Creates a csrf token form input of the kind: &lt;input type=&quot;hidden&quot; name=&quot;TOKEN_NAME&quot; value=&quot;TOKEN_VALUE&quot; /&gt;
</summary>
</member>
<member name="T:Saturn.CSRF.View">
<summary>
 Contains view helpers for csrf tokens for various view engines.
</summary>
</member>
<member name="T:Saturn.CSRF">
<summary>
Module containing helpers for CSRF Antiforgery protection
</summary>
</member>
<member name="M:Saturn.PipelineHelpers.requireHeader(System.String,System.String,Microsoft.FSharp.Core.FSharpFunc{Microsoft.AspNetCore.Http.HttpContext,System.Threading.Tasks.Task{Microsoft.FSharp.Core.FSharpOption{Microsoft.AspNetCore.Http.HttpContext}}},Microsoft.AspNetCore.Http.HttpContext)">
<summary>
Requires given value for given request header
</summary>
</member>
<member name="M:Saturn.PipelineHelpers.requestId(Microsoft.FSharp.Core.FSharpFunc{Microsoft.AspNetCore.Http.HttpContext,System.Threading.Tasks.Task{Microsoft.FSharp.Core.FSharpOption{Microsoft.AspNetCore.Http.HttpContext}}},Microsoft.AspNetCore.Http.HttpContext)">
<summary>
Pipeline for generating a unique request id for each request. A generated request id will in the format `uq8hs30oafhj5vve8ji5pmp7mtopc08f`.
If a request id already exists as the `x-request-id` HTTP request header, then that value will be used assuming it is between 20 and 200 characters. If it is not, a new request id will be generated.
Request id is put into `x-request-id` HTTP header and into `Items` directory of HttpContext with `RequestId` key.
</summary>
</member>
<member name="M:Saturn.PipelineHelpers.head(Microsoft.FSharp.Core.FSharpFunc{Microsoft.AspNetCore.Http.HttpContext,System.Threading.Tasks.Task{Microsoft.FSharp.Core.FSharpOption{Microsoft.AspNetCore.Http.HttpContext}}},Microsoft.AspNetCore.Http.HttpContext)">
<summary>
Convert `HEAD` requests to `GET` requests.
</summary>
</member>
<member name="M:Saturn.PipelineHelpers.fetchModel``1(Microsoft.FSharp.Core.FSharpOption{System.String},Microsoft.FSharp.Core.FSharpFunc{Microsoft.AspNetCore.Http.HttpContext,System.Threading.Tasks.Task{Microsoft.FSharp.Core.FSharpOption{Microsoft.AspNetCore.Http.HttpContext}}},Microsoft.AspNetCore.Http.HttpContext)">
<summary>
Tries to model from request and puts model into `Items.RequestModel`. If it won&apos;t be called content can be fetched using `Context.Controller` helpers.
It optionally takes custom culture name as arguments.
</summary>
</member>
<member name="M:Saturn.PipelineHelpers.fetchSession(Microsoft.FSharp.Core.FSharpFunc{Microsoft.AspNetCore.Http.HttpContext,System.Threading.Tasks.Task{Microsoft.FSharp.Core.FSharpOption{Microsoft.AspNetCore.Http.HttpContext}}},Microsoft.AspNetCore.Http.HttpContext)">
<summary>
Fetches session from session provider. If it won&apos;t be called session will be synchronusly fetched on first usage.
</summary>
</member>
<member name="M:Saturn.PipelineHelpers.enableCors(Saturn.CORS.CORSConfig)">
<summary>
Enables CORS pretection using provided config. Use `CORS.defaultCORSConfig` for default configuration.
</summary>
</member>
<member name="P:Saturn.PipelineHelpers.protectFromForgery">
<summary>
Enables CSRF protection using the (required) `Antiforgery` feature.
This feature can be set up via the `use_antiforgery` or `use_antiforgery_with_config` operations on the `application` builder.
This feature _requires_ that one of those be used (or some other mechanism of initializing the Antiforgery/Data Protection subsystems has been performed out-of-band)
</summary>
</member>
<member name="P:Saturn.PipelineHelpers.putSecureBrowserHeaders">
<summary>
 Put headers that improve browser security.
 It sets the following headers:
  * x-frame-options - set to SAMEORIGIN to avoid clickjacking through iframes unless in the same origin
  * x-content-type-options - set to nosniff. This requires script and style tags to be sent with proper content type
  * x-xss-protection - set to &quot;1; mode=block&quot; to improve XSS protection on both Chrome and IE
  * x-download-options - set to noopen to instruct the browser not to open a download directly in the browser, to avoid HTML files rendering inline and accessing the security context of the application (like critical domain cookies)
  * x-permitted-cross-domain-policies - set to none to restrict Adobe Flash Playerâ€™s access to data
</summary>
</member>
<member name="P:Saturn.PipelineHelpers.acceptMultipart">
<summary>
Accepts `multipart/form-data`
</summary>
</member>
<member name="P:Saturn.PipelineHelpers.acceptHtml">
<summary>
Accepts `text/html`
</summary>
</member>
<member name="P:Saturn.PipelineHelpers.acceptXml">
<summary>
Accepts `application/xml`
</summary>
</member>
<member name="P:Saturn.PipelineHelpers.acceptJson">
<summary>
Accepts `application/json`
</summary>
</member>
<member name="T:Saturn.PipelineHelpers">
<summary>
Module containing helper functions that can be used with `pipeline` computation expression
</summary>
</member>
<member name="M:Saturn.Pipeline.PipelineBuilder.Xml``1(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{Microsoft.AspNetCore.Http.HttpContext,System.Threading.Tasks.Task{Microsoft.FSharp.Core.FSharpOption{Microsoft.AspNetCore.Http.HttpContext}}},Microsoft.FSharp.Core.FSharpFunc{Microsoft.AspNetCore.Http.HttpContext,System.Threading.Tasks.Task{Microsoft.FSharp.Core.FSharpOption{Microsoft.AspNetCore.Http.HttpContext}}}},``0)">
<summary>
`xml` sets or modifies the body of the `HttpResponse` by sending an XML serialized object to the client. This http handler triggers a response to the client and other http handlers will not be able to modify the HTTP headers afterwards any more. It also sets the `Content-Type` HTTP header to `application/xml`.
</summary>
</member>
<member name="M:Saturn.Pipeline.PipelineBuilder.Warbler(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{Microsoft.AspNetCore.Http.HttpContext,System.Threading.Tasks.Task{Microsoft.FSharp.Core.FSharpOption{Microsoft.AspNetCore.Http.HttpContext}}},Microsoft.FSharp.Core.FSharpFunc{Microsoft.AspNetCore.Http.HttpContext,System.Threading.Tasks.Task{Microsoft.FSharp.Core.FSharpOption{Microsoft.AspNetCore.Http.HttpContext}}}})">
<summary>
If your route is not returning a static response, then you should wrap your function with a warbler. Functions in F# are eagerly evaluated and the warbler will help to evaluate the function every time the route is hit.
</summary>
</member>
<member name="M:Saturn.Pipeline.PipelineBuilder.Text(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{Microsoft.AspNetCore.Http.HttpContext,System.Threading.Tasks.Task{Microsoft.FSharp.Core.FSharpOption{Microsoft.AspNetCore.Http.HttpContext}}},Microsoft.FSharp.Core.FSharpFunc{Microsoft.AspNetCore.Http.HttpContext,System.Threading.Tasks.Task{Microsoft.FSharp.Core.FSharpOption{Microsoft.AspNetCore.Http.HttpContext}}}},System.String)">
<summary>
`text` sets or modifies the body of the `HttpResponse` by sending a plain text value to the client. This http handler triggers a response to the client and other http handlers will not be able to modify the HTTP headers afterwards any more. It also sets the `Content-Type` HTTP header to `text/plain`.
</summary>
</member>
<member name="M:Saturn.Pipeline.PipelineBuilder.SignOff(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{Microsoft.AspNetCore.Http.HttpContext,System.Threading.Tasks.Task{Microsoft.FSharp.Core.FSharpOption{Microsoft.AspNetCore.Http.HttpContext}}},Microsoft.FSharp.Core.FSharpFunc{Microsoft.AspNetCore.Http.HttpContext,System.Threading.Tasks.Task{Microsoft.FSharp.Core.FSharpOption{Microsoft.AspNetCore.Http.HttpContext}}}},System.String)">
<summary>
`sign_off` signs off the currently logged in user.
</summary>
</member>
<member name="M:Saturn.Pipeline.PipelineBuilder.SetStatusCode(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{Microsoft.AspNetCore.Http.HttpContext,System.Threading.Tasks.Task{Microsoft.FSharp.Core.FSharpOption{Microsoft.AspNetCore.Http.HttpContext}}},Microsoft.FSharp.Core.FSharpFunc{Microsoft.AspNetCore.Http.HttpContext,System.Threading.Tasks.Task{Microsoft.FSharp.Core.FSharpOption{Microsoft.AspNetCore.Http.HttpContext}}}},System.Int32)">
<summary>
`set_status_code` changes the status code of the `HttpResponse`.
</summary>
</member>
<member name="M:Saturn.Pipeline.PipelineBuilder.SetHeader``1(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{Microsoft.AspNetCore.Http.HttpContext,System.Threading.Tasks.Task{Microsoft.FSharp.Core.FSharpOption{Microsoft.AspNetCore.Http.HttpContext}}},Microsoft.FSharp.Core.FSharpFunc{Microsoft.AspNetCore.Http.HttpContext,System.Threading.Tasks.Task{Microsoft.FSharp.Core.FSharpOption{Microsoft.AspNetCore.Http.HttpContext}}}},System.String,``0)">
<summary>
`set_header` sets or modifies a HTTP header of the `HttpResponse`.
</summary>
</member>
<member name="M:Saturn.Pipeline.PipelineBuilder.SetBodyFromString(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{Microsoft.AspNetCore.Http.HttpContext,System.Threading.Tasks.Task{Microsoft.FSharp.Core.FSharpOption{Microsoft.AspNetCore.Http.HttpContext}}},Microsoft.FSharp.Core.FSharpFunc{Microsoft.AspNetCore.Http.HttpContext,System.Threading.Tasks.Task{Microsoft.FSharp.Core.FSharpOption{Microsoft.AspNetCore.Http.HttpContext}}}},System.String)">
<summary>
`set_body_from_string` sets or modifies the body of the `HttpResponse`. This http handler triggers a response to the client and other http handlers will not be able to modify the HTTP headers afterwards any more.
</summary>
</member>
<member name="M:Saturn.Pipeline.PipelineBuilder.SetBody(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{Microsoft.AspNetCore.Http.HttpContext,System.Threading.Tasks.Task{Microsoft.FSharp.Core.FSharpOption{Microsoft.AspNetCore.Http.HttpContext}}},Microsoft.FSharp.Core.FSharpFunc{Microsoft.AspNetCore.Http.HttpContext,System.Threading.Tasks.Task{Microsoft.FSharp.Core.FSharpOption{Microsoft.AspNetCore.Http.HttpContext}}}},System.Byte[])">
<summary>
`set_body` sets or modifies the body of the `HttpResponse`. This http handler triggers a response to the client and other http handlers will not be able to modify the HTTP headers afterwards any more.
</summary>
</member>
<member name="M:Saturn.Pipeline.PipelineBuilder.RoutePorts(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{Microsoft.AspNetCore.Http.HttpContext,System.Threading.Tasks.Task{Microsoft.FSharp.Core.FSharpOption{Microsoft.AspNetCore.Http.HttpContext}}},Microsoft.FSharp.Core.FSharpFunc{Microsoft.AspNetCore.Http.HttpContext,System.Threading.Tasks.Task{Microsoft.FSharp.Core.FSharpOption{Microsoft.AspNetCore.Http.HttpContext}}}},Microsoft.FSharp.Collections.FSharpList{System.Tuple{System.Int32,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{Microsoft.AspNetCore.Http.HttpContext,System.Threading.Tasks.Task{Microsoft.FSharp.Core.FSharpOption{Microsoft.AspNetCore.Http.HttpContext}}},Microsoft.FSharp.Core.FSharpFunc{Microsoft.AspNetCore.Http.HttpContext,System.Threading.Tasks.Task{Microsoft.FSharp.Core.FSharpOption{Microsoft.AspNetCore.Http.HttpContext}}}}}})">
<summary>
If your web server is listening to multiple ports then you can use the `routePorts` HttpHandler to easily filter incoming requests based on their port by providing a list of port number and HttpHandler (`(int * HttpHandler) list`).
</summary>
</member>
<member name="M:Saturn.Pipeline.PipelineBuilder.RequiresRoleOf(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{Microsoft.AspNetCore.Http.HttpContext,System.Threading.Tasks.Task{Microsoft.FSharp.Core.FSharpOption{Microsoft.AspNetCore.Http.HttpContext}}},Microsoft.FSharp.Core.FSharpFunc{Microsoft.AspNetCore.Http.HttpContext,System.Threading.Tasks.Task{Microsoft.FSharp.Core.FSharpOption{Microsoft.AspNetCore.Http.HttpContext}}}},Microsoft.FSharp.Collections.FSharpList{System.String},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{Microsoft.AspNetCore.Http.HttpContext,System.Threading.Tasks.Task{Microsoft.FSharp.Core.FSharpOption{Microsoft.AspNetCore.Http.HttpContext}}},Microsoft.FSharp.Core.FSharpFunc{Microsoft.AspNetCore.Http.HttpContext,System.Threading.Tasks.Task{Microsoft.FSharp.Core.FSharpOption{Microsoft.AspNetCore.Http.HttpContext}}}})">
<summary>
`requires_role_of` validates if an authenticated user is in one of the supplied roles. If the user fails to be in one of the required roles then the handler will execute the `authFailedHandler` function.
</summary>
</member>
<member name="M:Saturn.Pipeline.PipelineBuilder.RequiresRole(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{Microsoft.AspNetCore.Http.HttpContext,System.Threading.Tasks.Task{Microsoft.FSharp.Core.FSharpOption{Microsoft.AspNetCore.Http.HttpContext}}},Microsoft.FSharp.Core.FSharpFunc{Microsoft.AspNetCore.Http.HttpContext,System.Threading.Tasks.Task{Microsoft.FSharp.Core.FSharpOption{Microsoft.AspNetCore.Http.HttpContext}}}},System.String,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{Microsoft.AspNetCore.Http.HttpContext,System.Threading.Tasks.Task{Microsoft.FSharp.Core.FSharpOption{Microsoft.AspNetCore.Http.HttpContext}}},Microsoft.FSharp.Core.FSharpFunc{Microsoft.AspNetCore.Http.HttpContext,System.Threading.Tasks.Task{Microsoft.FSharp.Core.FSharpOption{Microsoft.AspNetCore.Http.HttpContext}}}})">
<summary>
`requires_role` validates if an authenticated user is in a specified role. If the user fails to be in the required role then the handler will execute the `authFailedHandler` function.
</summary>
</member>
<member name="M:Saturn.Pipeline.PipelineBuilder.RequiresPolicy``1(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{Microsoft.AspNetCore.Http.HttpContext,System.Threading.Tasks.Task{Microsoft.FSharp.Core.FSharpOption{Microsoft.AspNetCore.Http.HttpContext}}},Microsoft.FSharp.Core.FSharpFunc{Microsoft.AspNetCore.Http.HttpContext,System.Threading.Tasks.Task{Microsoft.FSharp.Core.FSharpOption{Microsoft.AspNetCore.Http.HttpContext}}}},System.String,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{``0,System.Threading.Tasks.Task{Microsoft.FSharp.Core.FSharpOption{``0}}},Microsoft.FSharp.Core.FSharpFunc{Microsoft.AspNetCore.Http.HttpContext,System.Threading.Tasks.Task{Microsoft.FSharp.Core.FSharpOption{Microsoft.AspNetCore.Http.HttpContext}}}})">
<summary>
`requires_policy` validates if a user satisfies a defined policy requirement, if not then the handler will execute the `authFailedHandler` function.
</summary>
</member>
<member name="M:Saturn.Pipeline.PipelineBuilder.RequiresAuthentication(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{Microsoft.AspNetCore.Http.HttpContext,System.Threading.Tasks.Task{Microsoft.FSharp.Core.FSharpOption{Microsoft.AspNetCore.Http.HttpContext}}},Microsoft.FSharp.Core.FSharpFunc{Microsoft.AspNetCore.Http.HttpContext,System.Threading.Tasks.Task{Microsoft.FSharp.Core.FSharpOption{Microsoft.AspNetCore.Http.HttpContext}}}},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{Microsoft.AspNetCore.Http.HttpContext,System.Threading.Tasks.Task{Microsoft.FSharp.Core.FSharpOption{Microsoft.AspNetCore.Http.HttpContext}}},Microsoft.FSharp.Core.FSharpFunc{Microsoft.AspNetCore.Http.HttpContext,System.Threading.Tasks.Task{Microsoft.FSharp.Core.FSharpOption{Microsoft.AspNetCore.Http.HttpContext}}}})">
<summary>
`requires_authentication` validates if a user is authenticated/logged in. If the user is not authenticated then the handler will execute the `authFailedHandler` function.
</summary>
</member>
<member name="M:Saturn.Pipeline.PipelineBuilder.RequiresAuthPolicy(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{Microsoft.AspNetCore.Http.HttpContext,System.Threading.Tasks.Task{Microsoft.FSharp.Core.FSharpOption{Microsoft.AspNetCore.Http.HttpContext}}},Microsoft.FSharp.Core.FSharpFunc{Microsoft.AspNetCore.Http.HttpContext,System.Threading.Tasks.Task{Microsoft.FSharp.Core.FSharpOption{Microsoft.AspNetCore.Http.HttpContext}}}},Microsoft.FSharp.Core.FSharpFunc{System.Security.Claims.ClaimsPrincipal,System.Boolean},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{Microsoft.AspNetCore.Http.HttpContext,System.Threading.Tasks.Task{Microsoft.FSharp.Core.FSharpOption{Microsoft.AspNetCore.Http.HttpContext}}},Microsoft.FSharp.Core.FSharpFunc{Microsoft.AspNetCore.Http.HttpContext,System.Threading.Tasks.Task{Microsoft.FSharp.Core.FSharpOption{Microsoft.AspNetCore.Http.HttpContext}}}})">
<summary>
`requires_auth_policy` validates if a user satisfies policy requirement, if not then the handler will execute the `authFailedHandler` function.
</summary>
</member>
<member name="M:Saturn.Pipeline.PipelineBuilder.RenderHtml(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{Microsoft.AspNetCore.Http.HttpContext,System.Threading.Tasks.Task{Microsoft.FSharp.Core.FSharpOption{Microsoft.AspNetCore.Http.HttpContext}}},Microsoft.FSharp.Core.FSharpFunc{Microsoft.AspNetCore.Http.HttpContext,System.Threading.Tasks.Task{Microsoft.FSharp.Core.FSharpOption{Microsoft.AspNetCore.Http.HttpContext}}}},Giraffe.GiraffeViewEngine.XmlNode)">
<summary>
`render_html` is a more functional way of generating HTML by composing HTML elements in F# to generate a rich Model-View output.
</summary>
</member>
<member name="M:Saturn.Pipeline.PipelineBuilder.RedirectTo(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{Microsoft.AspNetCore.Http.HttpContext,System.Threading.Tasks.Task{Microsoft.FSharp.Core.FSharpOption{Microsoft.AspNetCore.Http.HttpContext}}},Microsoft.FSharp.Core.FSharpFunc{Microsoft.AspNetCore.Http.HttpContext,System.Threading.Tasks.Task{Microsoft.FSharp.Core.FSharpOption{Microsoft.AspNetCore.Http.HttpContext}}}},System.Boolean,System.String)">
<summary>
`redirect_to` uses a 302 or 301 (when permanent) HTTP response code to redirect the client to the specified location. It takes in two parameters, a boolean flag denoting whether the redirect should be permanent or not and the location to redirect to.
</summary>
</member>
<member name="M:Saturn.Pipeline.PipelineBuilder.Plug(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{Microsoft.AspNetCore.Http.HttpContext,System.Threading.Tasks.Task{Microsoft.FSharp.Core.FSharpOption{Microsoft.AspNetCore.Http.HttpContext}}},Microsoft.FSharp.Core.FSharpFunc{Microsoft.AspNetCore.Http.HttpContext,System.Threading.Tasks.Task{Microsoft.FSharp.Core.FSharpOption{Microsoft.AspNetCore.Http.HttpContext}}}},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{Microsoft.AspNetCore.Http.HttpContext,System.Threading.Tasks.Task{Microsoft.FSharp.Core.FSharpOption{Microsoft.AspNetCore.Http.HttpContext}}},Microsoft.FSharp.Core.FSharpFunc{Microsoft.AspNetCore.Http.HttpContext,System.Threading.Tasks.Task{Microsoft.FSharp.Core.FSharpOption{Microsoft.AspNetCore.Http.HttpContext}}}})">
<summary>
`plug` enables adding any additional `HttpHandler` to the pipeline
</summary>
</member>
<member name="M:Saturn.Pipeline.PipelineBuilder.NegotiateWith``1(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{Microsoft.AspNetCore.Http.HttpContext,System.Threading.Tasks.Task{Microsoft.FSharp.Core.FSharpOption{Microsoft.AspNetCore.Http.HttpContext}}},Microsoft.FSharp.Core.FSharpFunc{Microsoft.AspNetCore.Http.HttpContext,System.Threading.Tasks.Task{Microsoft.FSharp.Core.FSharpOption{Microsoft.AspNetCore.Http.HttpContext}}}},System.Collections.Generic.IDictionary{System.String,Microsoft.FSharp.Core.FSharpFunc{System.Object,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{Microsoft.AspNetCore.Http.HttpContext,System.Threading.Tasks.Task{Microsoft.FSharp.Core.FSharpOption{Microsoft.AspNetCore.Http.HttpContext}}},Microsoft.FSharp.Core.FSharpFunc{Microsoft.AspNetCore.Http.HttpContext,System.Threading.Tasks.Task{Microsoft.FSharp.Core.FSharpOption{Microsoft.AspNetCore.Http.HttpContext}}}}}},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{Microsoft.AspNetCore.Http.HttpContext,System.Threading.Tasks.Task{Microsoft.FSharp.Core.FSharpOption{Microsoft.AspNetCore.Http.HttpContext}}},Microsoft.FSharp.Core.FSharpFunc{Microsoft.AspNetCore.Http.HttpContext,System.Threading.Tasks.Task{Microsoft.FSharp.Core.FSharpOption{Microsoft.AspNetCore.Http.HttpContext}}}},``0)">
<summary>
`negotiateWith` sets or modifies the body of the `HttpResponse` by inspecting the `Accept` header of the HTTP request and deciding in what mimeType the response should be sent. A dictionary of type `IDictionary&lt;string, obj -&gt; HttpHandler&gt;` is used to determine which `obj -&gt; HttpHandler` function should be used to convert an object into a `HttpHandler` for a given mime type. This http handler triggers a response to the client and other http handlers will not be able to modify the HTTP headers afterwards any more.
</summary>
</member>
<member name="M:Saturn.Pipeline.PipelineBuilder.Negotiate``1(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{Microsoft.AspNetCore.Http.HttpContext,System.Threading.Tasks.Task{Microsoft.FSharp.Core.FSharpOption{Microsoft.AspNetCore.Http.HttpContext}}},Microsoft.FSharp.Core.FSharpFunc{Microsoft.AspNetCore.Http.HttpContext,System.Threading.Tasks.Task{Microsoft.FSharp.Core.FSharpOption{Microsoft.AspNetCore.Http.HttpContext}}}},``0)">
<summary>
`negotiate` sets or modifies the body of the `HttpResponse` by inspecting the `Accept` header of the HTTP request and deciding if the response should be sent in JSON or XML or plain text. If the client is indifferent then the default response will be sent in JSON. This http handler triggers a response to the client and other http handlers will not be able to modify the HTTP headers afterwards any more.
</summary>
</member>
<member name="M:Saturn.Pipeline.PipelineBuilder.MustAccept(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{Microsoft.AspNetCore.Http.HttpContext,System.Threading.Tasks.Task{Microsoft.FSharp.Core.FSharpOption{Microsoft.AspNetCore.Http.HttpContext}}},Microsoft.FSharp.Core.FSharpFunc{Microsoft.AspNetCore.Http.HttpContext,System.Threading.Tasks.Task{Microsoft.FSharp.Core.FSharpOption{Microsoft.AspNetCore.Http.HttpContext}}}},Microsoft.FSharp.Collections.FSharpList{System.String})">
<summary>
`must_accept` filters a request by the `Accept` HTTP header. You can use it to check if a client accepts a certain mime type before returning a response.
</summary>
</member>
<member name="M:Saturn.Pipeline.PipelineBuilder.Json``1(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{Microsoft.AspNetCore.Http.HttpContext,System.Threading.Tasks.Task{Microsoft.FSharp.Core.FSharpOption{Microsoft.AspNetCore.Http.HttpContext}}},Microsoft.FSharp.Core.FSharpFunc{Microsoft.AspNetCore.Http.HttpContext,System.Threading.Tasks.Task{Microsoft.FSharp.Core.FSharpOption{Microsoft.AspNetCore.Http.HttpContext}}}},``0)">
<summary>
`json` sets or modifies the body of the `HttpResponse` by sending a JSON serialized object to the client. This http handler triggers a response to the client and other http handlers will not be able to modify the HTTP headers afterwards any more. It also sets the `Content-Type` HTTP header to `application/json`.
</summary>
</member>
<member name="M:Saturn.Pipeline.PipelineBuilder.HtmlFile(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{Microsoft.AspNetCore.Http.HttpContext,System.Threading.Tasks.Task{Microsoft.FSharp.Core.FSharpOption{Microsoft.AspNetCore.Http.HttpContext}}},Microsoft.FSharp.Core.FSharpFunc{Microsoft.AspNetCore.Http.HttpContext,System.Threading.Tasks.Task{Microsoft.FSharp.Core.FSharpOption{Microsoft.AspNetCore.Http.HttpContext}}}},System.String)">
<summary>
`html_file` sets or modifies the body of the `HttpResponse` with the contents of a physical html file. This http handler triggers a response to the client and other http handlers will not be able to modify the HTTP headers afterwards any more. This http handler takes a rooted path of a html file or a path which is relative to the ContentRootPath as the input parameter and sets the HTTP header `Content-Type` to `text/html`.
</summary>
</member>
<member name="M:Saturn.Pipeline.PipelineBuilder.Html(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{Microsoft.AspNetCore.Http.HttpContext,System.Threading.Tasks.Task{Microsoft.FSharp.Core.FSharpOption{Microsoft.AspNetCore.Http.HttpContext}}},Microsoft.FSharp.Core.FSharpFunc{Microsoft.AspNetCore.Http.HttpContext,System.Threading.Tasks.Task{Microsoft.FSharp.Core.FSharpOption{Microsoft.AspNetCore.Http.HttpContext}}}},System.String)">
<summary>
`html` sets or modifies the body of the `HttpResponse` with the contents of a single string variable. This http handler triggers a response to the client and other http handlers will not be able to modify the HTTP headers afterwards any more.
</summary>
</member>
<member name="M:Saturn.Pipeline.PipelineBuilder.ClearResponse(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{Microsoft.AspNetCore.Http.HttpContext,System.Threading.Tasks.Task{Microsoft.FSharp.Core.FSharpOption{Microsoft.AspNetCore.Http.HttpContext}}},Microsoft.FSharp.Core.FSharpFunc{Microsoft.AspNetCore.Http.HttpContext,System.Threading.Tasks.Task{Microsoft.FSharp.Core.FSharpOption{Microsoft.AspNetCore.Http.HttpContext}}}})">
<summary>
`clear_response` tries to clear the current response. This can be useful inside an error handler to reset the response before writing an error message to the body of the HTTP response object.
</summary>
</member>
<member name="M:Saturn.Pipeline.PipelineBuilder.Challenge(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{Microsoft.AspNetCore.Http.HttpContext,System.Threading.Tasks.Task{Microsoft.FSharp.Core.FSharpOption{Microsoft.AspNetCore.Http.HttpContext}}},Microsoft.FSharp.Core.FSharpFunc{Microsoft.AspNetCore.Http.HttpContext,System.Threading.Tasks.Task{Microsoft.FSharp.Core.FSharpOption{Microsoft.AspNetCore.Http.HttpContext}}}},System.String)">
<summary>
`challenge` challenges an authentication with a specified authentication scheme
</summary>
</member>
<member name="T:Saturn.Pipeline.PipelineBuilder">
<summary>
 Computation expression used to combine `HttpHandlers` in a declarative manner.

 The result of the computation expression is a standard Giraffe `HttpHandler` which means that it&apos;s easily composable with other parts of the Giraffe ecosystem.

 **Example:**

 ```fsharp
 let headerPipe = pipeline {
     set_header &quot;myCustomHeader&quot; &quot;abcd&quot;
     set_header &quot;myCustomHeader2&quot; &quot;zxcv&quot;
 }

 let endpointPipe = pipeline {
     plug fetchSession
     plug head
     plug requestId
 }
 ```
</summary>
</member>
<member name="P:Saturn.Pipeline.pipeline">
<summary>
`pipeline` computation expression is a way to create `HttpHandler` using composition of low-level helper functions.
</summary>
</member>
<member name="T:Saturn.Pipeline">
<summary>
Module containing `pipeline` computation expression
</summary>
</member>
<member name="M:Saturn.Router.RouterBuilder.PutF``5(Saturn.Router.RouterState,Microsoft.FSharp.Core.PrintfFormat{``0,``1,``2,``3,``4},Microsoft.FSharp.Core.FSharpFunc{``4,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{Microsoft.AspNetCore.Http.HttpContext,System.Threading.Tasks.Task{Microsoft.FSharp.Core.FSharpOption{Microsoft.AspNetCore.Http.HttpContext}}},Microsoft.FSharp.Core.FSharpFunc{Microsoft.AspNetCore.Http.HttpContext,System.Threading.Tasks.Task{Microsoft.FSharp.Core.FSharpOption{Microsoft.AspNetCore.Http.HttpContext}}}}})">
<summary>
Adds handler for `PUT` request.
</summary>
</member>
<member name="M:Saturn.Router.RouterBuilder.Put(Saturn.Router.RouterState,System.String,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{Microsoft.AspNetCore.Http.HttpContext,System.Threading.Tasks.Task{Microsoft.FSharp.Core.FSharpOption{Microsoft.AspNetCore.Http.HttpContext}}},Microsoft.FSharp.Core.FSharpFunc{Microsoft.AspNetCore.Http.HttpContext,System.Threading.Tasks.Task{Microsoft.FSharp.Core.FSharpOption{Microsoft.AspNetCore.Http.HttpContext}}}})">
<summary>
Adds handler for `PUT` request.
</summary>
</member>
<member name="M:Saturn.Router.RouterBuilder.PostF``5(Saturn.Router.RouterState,Microsoft.FSharp.Core.PrintfFormat{``0,``1,``2,``3,``4},Microsoft.FSharp.Core.FSharpFunc{``4,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{Microsoft.AspNetCore.Http.HttpContext,System.Threading.Tasks.Task{Microsoft.FSharp.Core.FSharpOption{Microsoft.AspNetCore.Http.HttpContext}}},Microsoft.FSharp.Core.FSharpFunc{Microsoft.AspNetCore.Http.HttpContext,System.Threading.Tasks.Task{Microsoft.FSharp.Core.FSharpOption{Microsoft.AspNetCore.Http.HttpContext}}}}})">
<summary>
Adds handler for `POST` request.
</summary>
</member>
<member name="M:Saturn.Router.RouterBuilder.Post(Saturn.Router.RouterState,System.String,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{Microsoft.AspNetCore.Http.HttpContext,System.Threading.Tasks.Task{Microsoft.FSharp.Core.FSharpOption{Microsoft.AspNetCore.Http.HttpContext}}},Microsoft.FSharp.Core.FSharpFunc{Microsoft.AspNetCore.Http.HttpContext,System.Threading.Tasks.Task{Microsoft.FSharp.Core.FSharpOption{Microsoft.AspNetCore.Http.HttpContext}}}})">
<summary>
Adds handler for `POST` request.
</summary>
</member>
<member name="M:Saturn.Router.RouterBuilder.PipeThrough(Saturn.Router.RouterState,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{Microsoft.AspNetCore.Http.HttpContext,System.Threading.Tasks.Task{Microsoft.FSharp.Core.FSharpOption{Microsoft.AspNetCore.Http.HttpContext}}},Microsoft.FSharp.Core.FSharpFunc{Microsoft.AspNetCore.Http.HttpContext,System.Threading.Tasks.Task{Microsoft.FSharp.Core.FSharpOption{Microsoft.AspNetCore.Http.HttpContext}}}})">
<summary>
Adds pipeline to the list of pipelines that will be used for every request
</summary>
</member>
<member name="M:Saturn.Router.RouterBuilder.PatchF``5(Saturn.Router.RouterState,Microsoft.FSharp.Core.PrintfFormat{``0,``1,``2,``3,``4},Microsoft.FSharp.Core.FSharpFunc{``4,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{Microsoft.AspNetCore.Http.HttpContext,System.Threading.Tasks.Task{Microsoft.FSharp.Core.FSharpOption{Microsoft.AspNetCore.Http.HttpContext}}},Microsoft.FSharp.Core.FSharpFunc{Microsoft.AspNetCore.Http.HttpContext,System.Threading.Tasks.Task{Microsoft.FSharp.Core.FSharpOption{Microsoft.AspNetCore.Http.HttpContext}}}}})">
<summary>
Adds handler for `PATCH` request.
</summary>
</member>
<member name="M:Saturn.Router.RouterBuilder.Patch(Saturn.Router.RouterState,System.String,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{Microsoft.AspNetCore.Http.HttpContext,System.Threading.Tasks.Task{Microsoft.FSharp.Core.FSharpOption{Microsoft.AspNetCore.Http.HttpContext}}},Microsoft.FSharp.Core.FSharpFunc{Microsoft.AspNetCore.Http.HttpContext,System.Threading.Tasks.Task{Microsoft.FSharp.Core.FSharpOption{Microsoft.AspNetCore.Http.HttpContext}}}})">
<summary>
Adds handler for `PATCH` request.
</summary>
</member>
<member name="M:Saturn.Router.RouterBuilder.NotFoundHandler(Saturn.Router.RouterState,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{Microsoft.AspNetCore.Http.HttpContext,System.Threading.Tasks.Task{Microsoft.FSharp.Core.FSharpOption{Microsoft.AspNetCore.Http.HttpContext}}},Microsoft.FSharp.Core.FSharpFunc{Microsoft.AspNetCore.Http.HttpContext,System.Threading.Tasks.Task{Microsoft.FSharp.Core.FSharpOption{Microsoft.AspNetCore.Http.HttpContext}}}})">
<summary>
Adds not-found handler for current scope
</summary>
</member>
<member name="M:Saturn.Router.RouterBuilder.GetF``5(Saturn.Router.RouterState,Microsoft.FSharp.Core.PrintfFormat{``0,``1,``2,``3,``4},Microsoft.FSharp.Core.FSharpFunc{``4,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{Microsoft.AspNetCore.Http.HttpContext,System.Threading.Tasks.Task{Microsoft.FSharp.Core.FSharpOption{Microsoft.AspNetCore.Http.HttpContext}}},Microsoft.FSharp.Core.FSharpFunc{Microsoft.AspNetCore.Http.HttpContext,System.Threading.Tasks.Task{Microsoft.FSharp.Core.FSharpOption{Microsoft.AspNetCore.Http.HttpContext}}}}})">
<summary>
Adds handler for `GET` request.
</summary>
</member>
<member name="M:Saturn.Router.RouterBuilder.Get(Saturn.Router.RouterState,System.String,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{Microsoft.AspNetCore.Http.HttpContext,System.Threading.Tasks.Task{Microsoft.FSharp.Core.FSharpOption{Microsoft.AspNetCore.Http.HttpContext}}},Microsoft.FSharp.Core.FSharpFunc{Microsoft.AspNetCore.Http.HttpContext,System.Threading.Tasks.Task{Microsoft.FSharp.Core.FSharpOption{Microsoft.AspNetCore.Http.HttpContext}}}})">
<summary>
Adds handler for `GET` request.
</summary>
</member>
<member name="M:Saturn.Router.RouterBuilder.Forwardf``5(Saturn.Router.RouterState,Microsoft.FSharp.Core.PrintfFormat{``0,``1,``2,``3,``4},Microsoft.FSharp.Core.FSharpFunc{``4,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{Microsoft.AspNetCore.Http.HttpContext,System.Threading.Tasks.Task{Microsoft.FSharp.Core.FSharpOption{Microsoft.AspNetCore.Http.HttpContext}}},Microsoft.FSharp.Core.FSharpFunc{Microsoft.AspNetCore.Http.HttpContext,System.Threading.Tasks.Task{Microsoft.FSharp.Core.FSharpOption{Microsoft.AspNetCore.Http.HttpContext}}}}})">
<summary>
Forwards calls to different `scope`. Modifies the `HttpRequest.Path` to allow subrouting.
</summary>
</member>
<member name="M:Saturn.Router.RouterBuilder.Forward(Saturn.Router.RouterState,System.String,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{Microsoft.AspNetCore.Http.HttpContext,System.Threading.Tasks.Task{Microsoft.FSharp.Core.FSharpOption{Microsoft.AspNetCore.Http.HttpContext}}},Microsoft.FSharp.Core.FSharpFunc{Microsoft.AspNetCore.Http.HttpContext,System.Threading.Tasks.Task{Microsoft.FSharp.Core.FSharpOption{Microsoft.AspNetCore.Http.HttpContext}}}})">
<summary>
Forwards calls to different `scope`. Modifies the `HttpRequest.Path` to allow subrouting.
</summary>
</member>
<member name="M:Saturn.Router.RouterBuilder.DeleteF``5(Saturn.Router.RouterState,Microsoft.FSharp.Core.PrintfFormat{``0,``1,``2,``3,``4},Microsoft.FSharp.Core.FSharpFunc{``4,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{Microsoft.AspNetCore.Http.HttpContext,System.Threading.Tasks.Task{Microsoft.FSharp.Core.FSharpOption{Microsoft.AspNetCore.Http.HttpContext}}},Microsoft.FSharp.Core.FSharpFunc{Microsoft.AspNetCore.Http.HttpContext,System.Threading.Tasks.Task{Microsoft.FSharp.Core.FSharpOption{Microsoft.AspNetCore.Http.HttpContext}}}}})">
<summary>
Adds handler for `DELETE` request.
</summary>
</member>
<member name="M:Saturn.Router.RouterBuilder.Delete(Saturn.Router.RouterState,System.String,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{Microsoft.AspNetCore.Http.HttpContext,System.Threading.Tasks.Task{Microsoft.FSharp.Core.FSharpOption{Microsoft.AspNetCore.Http.HttpContext}}},Microsoft.FSharp.Core.FSharpFunc{Microsoft.AspNetCore.Http.HttpContext,System.Threading.Tasks.Task{Microsoft.FSharp.Core.FSharpOption{Microsoft.AspNetCore.Http.HttpContext}}}})">
<summary>
Adds handler for `DELETE` request.
</summary>
</member>
<member name="M:Saturn.Router.RouterBuilder.CaseInsensitive(Saturn.Router.RouterState)">
<summary>
Toggle case insensitve routing
</summary>
</member>
<member name="T:Saturn.Router.RouterBuilder">
<summary>
 Computation expression used to create routing, combining `HttpHandlers`, `pipelines` and `controllers` together.

 The result of the computation expression is a standard Giraffe `HttpHandler`, which means that it&apos;s easily composable with other parts of the ecosytem.

 **Example:**

 ```fsharp
 let topRouter = router {
     pipe_through headerPipe
     not_found_handler (text &quot;404&quot;)

     get &quot;/&quot; helloWorld
     get &quot;/a&quot; helloWorld2
     getf &quot;/name/%s&quot; helloWorldName
     getf &quot;/name/%s/%i&quot; helloWorldNameAge

     //routers can be defined inline to simulate `subRoute` combinator
     forward &quot;/other&quot; (router {
         pipe_through otherHeaderPipe
         not_found_handler (text &quot;Other 404&quot;)

         get &quot;/&quot; otherHelloWorld
         get &quot;/a&quot; otherHelloWorld2
     })

     // or can be defined separatly and used as HttpHandler
     forward &quot;/api&quot; apiRouter

     // same with controllers
     forward &quot;/users&quot; userController
 }
 ```
</summary>
</member>
<member name="T:Saturn.Router.RouterState">
<summary>
Type representing internal state of the `router` computation expression
</summary>
</member>
<member name="T:Saturn.Router.RouteType">
<summary>
Type representing route type, used in internal state of the `application` computation expression
</summary>
</member>
<member name="P:Saturn.Router.router">
<summary>
Computation expression used to create routing in Saturn application
</summary>
</member>
<member name="T:Saturn.Router">
<summary>
Module containing `pipeline` computation expression
</summary>
</member>
<member name="T:Saturn.ControllerHelpers.Response">
<summary>
 This module wraps Giraffe responses (ie setting HTTP status codes) for easy chaining in the Saturn model.
 All of the functions set the status code and halt further processing.
</summary>
</member>
<member name="M:Saturn.ControllerHelpers.Controller.redirect(Microsoft.AspNetCore.Http.HttpContext,System.String)">
<summary>
Perform a temporary redirect to the provided location.
</summary>
</member>
<member name="M:Saturn.ControllerHelpers.Controller.sendDownloadBinary(Microsoft.AspNetCore.Http.HttpContext,System.Byte[])">
<summary>
Send bytes as the body of the response. Does not set a Content-Type.
</summary>
</member>
<member name="M:Saturn.ControllerHelpers.Controller.sendDownload(Microsoft.AspNetCore.Http.HttpContext,System.String)">
<summary>
Sends the contents of a file as the body of the response. Does not set a Content-Type.
</summary>
</member>
<member name="M:Saturn.ControllerHelpers.Controller.getConfig``1(Microsoft.AspNetCore.Http.HttpContext)">
<summary>
Gets the contents of the `Configuration` key in the HttpContext dictionary, unboxed as the given type.
</summary>
</member>
<member name="M:Saturn.ControllerHelpers.Controller.getUrl(Microsoft.AspNetCore.Http.HttpContext)">
<summary>
Gets url of the request
</summary>
</member>
<member name="M:Saturn.ControllerHelpers.Controller.getPath(Microsoft.AspNetCore.Http.HttpContext)">
<summary>
Gets path of the request - it&apos;s relative to current `scope`
</summary>
</member>
<member name="M:Saturn.ControllerHelpers.Controller.loadModel``1(Microsoft.AspNetCore.Http.HttpContext)">
<summary>
Loads model populated by `fetchModel` pipeline
</summary>
</member>
<member name="M:Saturn.ControllerHelpers.Controller.getModelCustom``1(Microsoft.AspNetCore.Http.HttpContext,Microsoft.FSharp.Core.FSharpOption{System.String})">
<summary>
Get model based on `HttpMethod` and `Content-Type` of request. Accepts custom culture.
</summary>
</member>
<member name="M:Saturn.ControllerHelpers.Controller.getModel``1(Microsoft.AspNetCore.Http.HttpContext)">
<summary>
Get model based on `HttpMethod` and `Content-Type` of request.
</summary>
</member>
<member name="M:Saturn.ControllerHelpers.Controller.getQueryCulture``1(Microsoft.AspNetCore.Http.HttpContext,System.String)">
<summary>
Gets model from query string. Accepts culture name
</summary>
</member>
<member name="M:Saturn.ControllerHelpers.Controller.getQuery``1(Microsoft.AspNetCore.Http.HttpContext)">
<summary>
Gets model from query string.
</summary>
</member>
<member name="M:Saturn.ControllerHelpers.Controller.getFormCulture``1(Microsoft.AspNetCore.Http.HttpContext,System.String)">
<summary>
Gets model from urelencoded body. Accepts culture name
</summary>
</member>
<member name="M:Saturn.ControllerHelpers.Controller.getForm``1(Microsoft.AspNetCore.Http.HttpContext)">
<summary>
Gets model from urelencoded body.
</summary>
</member>
<member name="M:Saturn.ControllerHelpers.Controller.getXml``1(Microsoft.AspNetCore.Http.HttpContext)">
<summary>
Gets model from body as XML.
</summary>
</member>
<member name="M:Saturn.ControllerHelpers.Controller.getJson``1(Microsoft.AspNetCore.Http.HttpContext)">
<summary>
Gets model from body as JSON.
</summary>
</member>
<member name="M:Saturn.ControllerHelpers.Controller.response``1(Microsoft.AspNetCore.Http.HttpContext,``0)">
<summary>
Returns to the client response according to accepted content type (`Accept` header, and if it&apos;s not present `Content-Type` header)
</summary>
</member>
<member name="M:Saturn.ControllerHelpers.Controller.file(Microsoft.AspNetCore.Http.HttpContext,System.String)">
<summary>
Returns to the client static file.
</summary>
</member>
<member name="M:Saturn.ControllerHelpers.Controller.renderHtml(Microsoft.AspNetCore.Http.HttpContext,Giraffe.GiraffeViewEngine.XmlNode)">
<summary>
Returns to the client rendered html template.
</summary>
</member>
<member name="M:Saturn.ControllerHelpers.Controller.html(Microsoft.AspNetCore.Http.HttpContext,System.String)">
<summary>
Returns the string template as html to the client.
</summary>
</member>
<member name="M:Saturn.ControllerHelpers.Controller.text(Microsoft.AspNetCore.Http.HttpContext,System.String)">
<summary>
Returns to the client content as string.
</summary>
</member>
<member name="M:Saturn.ControllerHelpers.Controller.xml``1(Microsoft.AspNetCore.Http.HttpContext,``0)">
<summary>
Returns to the client content serialized to XML.
</summary>
</member>
<member name="M:Saturn.ControllerHelpers.Controller.jsonCustom``2(Microsoft.AspNetCore.Http.HttpContext,``0,``1)">
<summary>
Returns to the client content serialized to JSON. Accepts custom serialization settings
</summary>
</member>
<member name="M:Saturn.ControllerHelpers.Controller.json``1(Microsoft.AspNetCore.Http.HttpContext,``0)">
<summary>
Returns to the client content serialized to JSON.
</summary>
</member>
<member name="T:Saturn.ControllerHelpers.Controller">
<summary>
Module containing helpers for `controller` actions
</summary>
</member>
<member name="T:Saturn.ControllerHelpers">
<summary>
Module containing helpers for `controller` actions
</summary>
</member>
<member name="M:Saturn.Controller.ControllerBuilder`10.Version``10(Saturn.Controller.ControllerState{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9},System.String)">
<summary>
Define version of controller. Adds checking of `x-controller-version` header
</summary>
</member>
<member name="M:Saturn.Controller.ControllerBuilder`10.Update``8(Saturn.Controller.ControllerState{`0,``0,``1,``2,``3,``4,`6,``5,``6,``7},Microsoft.FSharp.Core.FSharpFunc{Microsoft.AspNetCore.Http.HttpContext,Microsoft.FSharp.Core.FSharpFunc{`0,System.Threading.Tasks.Task{`6}}})">
<summary>
Operation that updates existing item
</summary>
</member>
<member name="M:Saturn.Controller.ControllerBuilder`10.SubController``10(Saturn.Controller.ControllerState{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9},System.String,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{Microsoft.AspNetCore.Http.HttpContext,System.Threading.Tasks.Task{Microsoft.FSharp.Core.FSharpOption{Microsoft.AspNetCore.Http.HttpContext}}},Microsoft.FSharp.Core.FSharpFunc{Microsoft.AspNetCore.Http.HttpContext,System.Threading.Tasks.Task{Microsoft.FSharp.Core.FSharpOption{Microsoft.AspNetCore.Http.HttpContext}}}}})">
<summary>
Inject a controller into the routing table rooted at a given route. All of that controller&apos;s actions will be anchored off of the route as a prefix.
</summary>
</member>
<member name="M:Saturn.Controller.ControllerBuilder`10.Show``8(Saturn.Controller.ControllerState{`0,``0,`2,``1,``2,``3,``4,``5,``6,``7},Microsoft.FSharp.Core.FSharpFunc{Microsoft.AspNetCore.Http.HttpContext,Microsoft.FSharp.Core.FSharpFunc{`0,System.Threading.Tasks.Task{`2}}})">
<summary>
Operation that should render (or return in case of API controllers) single entry of data
</summary>
</member>
<member name="M:Saturn.Controller.ControllerBuilder`10.Plug``10(Saturn.Controller.ControllerState{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9},Microsoft.FSharp.Collections.FSharpList{Saturn.Controller.Action},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{Microsoft.AspNetCore.Http.HttpContext,System.Threading.Tasks.Task{Microsoft.FSharp.Core.FSharpOption{Microsoft.AspNetCore.Http.HttpContext}}},Microsoft.FSharp.Core.FSharpFunc{Microsoft.AspNetCore.Http.HttpContext,System.Threading.Tasks.Task{Microsoft.FSharp.Core.FSharpOption{Microsoft.AspNetCore.Http.HttpContext}}}})">
<summary>
Add a plug that will be run on each of the provided actions.
</summary>
</member>
<member name="M:Saturn.Controller.ControllerBuilder`10.Patch``8(Saturn.Controller.ControllerState{`0,``0,``1,``2,``3,``4,``5,`7,``6,``7},Microsoft.FSharp.Core.FSharpFunc{Microsoft.AspNetCore.Http.HttpContext,Microsoft.FSharp.Core.FSharpFunc{`0,System.Threading.Tasks.Task{`7}}})">
<summary>
Operation that patches existing item
</summary>
</member>
<member name="M:Saturn.Controller.ControllerBuilder`10.NotFoundHandler``10(Saturn.Controller.ControllerState{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{Microsoft.AspNetCore.Http.HttpContext,System.Threading.Tasks.Task{Microsoft.FSharp.Core.FSharpOption{Microsoft.AspNetCore.Http.HttpContext}}},Microsoft.FSharp.Core.FSharpFunc{Microsoft.AspNetCore.Http.HttpContext,System.Threading.Tasks.Task{Microsoft.FSharp.Core.FSharpOption{Microsoft.AspNetCore.Http.HttpContext}}}})">
<summary>
Define not-found handler for the controller
</summary>
</member>
<member name="M:Saturn.Controller.ControllerBuilder`10.Index``9(Saturn.Controller.ControllerState{``0,`1,``1,``2,``3,``4,``5,``6,``7,``8},Microsoft.FSharp.Core.FSharpFunc{Microsoft.AspNetCore.Http.HttpContext,System.Threading.Tasks.Task{`1}})">
<summary>
Operation that should render (or return in case of API controllers) list of data
</summary>
</member>
<member name="M:Saturn.Controller.ControllerBuilder`10.ErrorHandler``10(Saturn.Controller.ControllerState{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9},Microsoft.FSharp.Core.FSharpFunc{Microsoft.AspNetCore.Http.HttpContext,Microsoft.FSharp.Core.FSharpFunc{System.Exception,System.Threading.Tasks.Task{Microsoft.FSharp.Core.FSharpOption{Microsoft.AspNetCore.Http.HttpContext}}}})">
<summary>
Define error for the controller
</summary>
</member>
<member name="M:Saturn.Controller.ControllerBuilder`10.Edit``8(Saturn.Controller.ControllerState{`0,``0,``1,``2,`4,``3,``4,``5,``6,``7},Microsoft.FSharp.Core.FSharpFunc{Microsoft.AspNetCore.Http.HttpContext,Microsoft.FSharp.Core.FSharpFunc{`0,System.Threading.Tasks.Task{`4}}})">
<summary>
Operation that should render form for editing existing item
</summary>
</member>
<member name="M:Saturn.Controller.ControllerBuilder`10.DeleteAll``9(Saturn.Controller.ControllerState{``0,``1,``2,``3,``4,``5,``6,``7,``8,`9},Microsoft.FSharp.Core.FSharpFunc{Microsoft.AspNetCore.Http.HttpContext,System.Threading.Tasks.Task{`9}})">
<summary>
Operation that deletes all items
</summary>
</member>
<member name="M:Saturn.Controller.ControllerBuilder`10.Delete``8(Saturn.Controller.ControllerState{`0,``0,``1,``2,``3,``4,``5,``6,`8,``7},Microsoft.FSharp.Core.FSharpFunc{Microsoft.AspNetCore.Http.HttpContext,Microsoft.FSharp.Core.FSharpFunc{`0,System.Threading.Tasks.Task{`8}}})">
<summary>
Operation that deletes existing item
</summary>
</member>
<member name="M:Saturn.Controller.ControllerBuilder`10.Create``9(Saturn.Controller.ControllerState{``0,``1,``2,``3,``4,`5,``5,``6,``7,``8},Microsoft.FSharp.Core.FSharpFunc{Microsoft.AspNetCore.Http.HttpContext,System.Threading.Tasks.Task{`5}})">
<summary>
Operation that creates new item
</summary>
</member>
<member name="M:Saturn.Controller.ControllerBuilder`10.CaseInsensitive``10(Saturn.Controller.ControllerState{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9})">
<summary>
Toggle case insensitve routing
</summary>
</member>
<member name="M:Saturn.Controller.ControllerBuilder`10.Add``9(Saturn.Controller.ControllerState{``0,``1,``2,`3,``3,``4,``5,``6,``7,``8},Microsoft.FSharp.Core.FSharpFunc{Microsoft.AspNetCore.Http.HttpContext,System.Threading.Tasks.Task{`3}})">
<summary>
Operation that should render form for adding new item
</summary>
</member>
<member name="T:Saturn.Controller.ControllerBuilder`10">
<summary>
Computation expression used to create Saturn controllers - abstraction representing REST-ish endpoint for serving HTML views or returning data. It supports:

 * a set of predefined actions that are automatically mapped to the endpoints following standard conventions
 * embedding sub-controllers for modeling one-to-many relationships
 * versioning
 * adding plugs for a particular action which in principle provides the same mechanism as attributes in ASP.NET MVC applications
 * defining a common error handler for all actions
 * defining a not-found action

The result of the computation expression is a standard Giraffe `HttpHandler`, which means that it&apos;s easily composable with other parts of the ecosytem.

**Example:**

 ```fsharp
 let commentController userId = controller {
     index (fun ctx -&gt; (sprintf &quot;Comment Index handler for user %i&quot; userId ) |&gt; Controller.text ctx)
     add (fun ctx -&gt; (sprintf &quot;Comment Add handler for user %i&quot; userId ) |&gt; Controller.text ctx)
     show (fun (ctx, id) -&gt; (sprintf &quot;Show comment %s handler for user %i&quot; id userId ) |&gt; Controller.text ctx)
     edit (fun (ctx, id) -&gt; (sprintf &quot;Edit comment %s handler for user %i&quot; id userId )  |&gt; Controller.text ctx)
 }

 let userControllerVersion1 = controller {
     version 1
     subController &quot;/comments&quot; commentController

     index (fun ctx -&gt; &quot;Index handler version 1&quot; |&gt; Controller.text ctx)
     add (fun ctx -&gt; &quot;Add handler version 1&quot; |&gt; Controller.text ctx)
     show (fun (ctx, id) -&gt; (sprintf &quot;Show handler version 1 - %i&quot; id) |&gt; Controller.text ctx)
     edit (fun (ctx, id) -&gt; (sprintf &quot;Edit handler version 1 - %i&quot; id) |&gt; Controller.text ctx)
 }

 let userController = controller {
     subController &quot;/comments&quot; commentController

     plug [All] (setHttpHeader &quot;user-controller-common&quot; &quot;123&quot;)
     plug [Index; Show] (setHttpHeader &quot;user-controller-specialized&quot; &quot;123&quot;)

     index (fun ctx -&gt; &quot;Index handler no version&quot; |&gt; Controller.text ctx)
     add (fun ctx -&gt; &quot;Add handler no version&quot; |&gt; Controller.text ctx)
     show (fun (ctx, id) -&gt; (sprintf &quot;Show handler no version - %i&quot; id) |&gt; Controller.text ctx)
     edit (fun (ctx, id) -&gt; (sprintf &quot;Edit handler no version - %i&quot; id) |&gt; Controller.text ctx)
 }
 ```
</summary>
</member>
<member name="T:Saturn.Controller.ControllerState`10">
<summary>
Type representing internal state of the `controller` computation expression
</summary>
</member>
<member name="T:Saturn.Controller.Action">
<summary>
Type used for `plug` operation, allowing you to choose for which actions given plug should work
</summary>
</member>
<member name="M:Saturn.Controller.controller``10">
<summary>
Computation expression used to create controllers
</summary>
</member>
<member name="M:Saturn.Controller.except(Microsoft.FSharp.Collections.FSharpList{Saturn.Controller.Action})">
<summary>
Returns list of all actions except given actions.
</summary>
</member>
<member name="T:Saturn.Controller">
<summary>
Module with `controller` computation expression
</summary>
</member>
<member name="M:Saturn.Auth.generateJWT(System.String,System.String,System.String,System.DateTime,System.Collections.Generic.IEnumerable{System.Security.Claims.Claim})">
<summary>
Helper function to generate JWT token using `Microsoft.IdentityModel.Tokens` and `System.IdentityModel.Tokens.Jwt`
</summary>
</member>
<member name="M:Saturn.Auth.requireClaim(Saturn.ChallengeType.ChallengeType,System.String,System.String)">
<summary>
Requires claim of given type with given value and uses given challenge type if not authenticated
</summary>
</member>
<member name="M:Saturn.Auth.requireRoleOf(Saturn.ChallengeType.ChallengeType,Microsoft.FSharp.Collections.FSharpList{System.String})">
<summary>
Requires one of the roles and uses given challenge type if not authenticated
</summary>
</member>
<member name="M:Saturn.Auth.requireRole(Saturn.ChallengeType.ChallengeType,System.String)">
<summary>
Requires role and uses given challenge type if not authenticated
</summary>
</member>
<member name="M:Saturn.Auth.requireAuthentication(Saturn.ChallengeType.ChallengeType)">
<summary>
Requires authentication and uses given challenge type if not authenticated
</summary>
</member>
<member name="T:Saturn.Auth">
<summary>
Module with some useful helpers functions that can be used for authentication, such as creating JWT tokens, or `HttpHandlers` checking if request is authenticated.
</summary>
</member>
<member name="P:Saturn.OAuth.OAuthSettings.Claims">
<summary>
Sequance of tuples where first element is a name of the of the key in JSON object and second element is a name of the claim.
For example: `[&quot;login&quot;, &quot;githubUsername&quot;; &quot;name&quot;, &quot;fullName&quot;]` where `login` and `name` are names of fields in GitHub JSON response (https://developer.github.com/v3/users/#get-the-authenticated-user).
</summary>
</member>
<member name="P:Saturn.OAuth.OAuthSettings.UserInformationEndpoint">
<summary>
OAuth User Information endpoint
For example: https://api.github.com/user
</summary>
</member>
<member name="P:Saturn.OAuth.OAuthSettings.TokenEndpoint">
<summary>
OAuth Token endpoint
For example: https://github.com/login/oauth/access_token
</summary>
</member>
<member name="P:Saturn.OAuth.OAuthSettings.AuthorizationEndpoint">
<summary>
OAuth Authorization endpoint
For example: https://github.com/login/oauth/authorize
</summary>
</member>
<member name="P:Saturn.OAuth.OAuthSettings.CallbackPath">
<summary>
OAuth CallbackPath endpoint
</summary>
</member>
<member name="P:Saturn.OAuth.OAuthSettings.Schema">
<summary>
Name of the schema to be registered
</summary>
</member>
<member name="T:Saturn.OAuth.OAuthSettings">
<summary>
Record type representing simple OAuth configuration to be used with `use_oauth_with_settings`.
</summary>
</member>
<member name="T:Saturn.OAuth">
<summary>
Module containing types to be use with `use_oauth_with_settings`
</summary>
</member>
<member name="M:Saturn.ChannelBuilder.ChannelBuilder.Terminate(Saturn.ChannelBuilder.ChannelBuilderState,Microsoft.FSharp.Core.FSharpFunc{Microsoft.AspNetCore.Http.HttpContext,Microsoft.FSharp.Core.FSharpFunc{Saturn.Channels.ClientInfo,System.Threading.Tasks.Task{Microsoft.FSharp.Core.Unit}}})">
<summary>
Action executed when client disconnects from the channel

 As arguments, `join` action gets:
 *  current `HttpContext` for the request
 * `ClientInfo` instance representing additional information about client sending request
</summary>
</member>
<member name="M:Saturn.ChannelBuilder.ChannelBuilder.NotFoundHandler(Saturn.ChannelBuilder.ChannelBuilderState,Microsoft.FSharp.Core.FSharpFunc{Microsoft.AspNetCore.Http.HttpContext,Microsoft.FSharp.Core.FSharpFunc{Saturn.Channels.ClientInfo,Microsoft.FSharp.Core.FSharpFunc{Saturn.Channels.Message{System.Object},System.Threading.Tasks.Task{Microsoft.FSharp.Core.Unit}}}})">
<summary>
Action executed when clients sends a message to the topic for which `handle` was not registered

 As arguments, `not_found_handler` action gets:
 *  current `HttpContext` for the request
 * `ClientInfo` instance representing additional information about client sending request
 * `Message&lt;&apos;a&gt;` instance representing message sent from client to the channel
</summary>
</member>
<member name="M:Saturn.ChannelBuilder.ChannelBuilder.Join(Saturn.ChannelBuilder.ChannelBuilderState,Microsoft.FSharp.Core.FSharpFunc{Microsoft.AspNetCore.Http.HttpContext,Microsoft.FSharp.Core.FSharpFunc{Saturn.Channels.ClientInfo,System.Threading.Tasks.Task{Saturn.Channels.JoinResult}}})">
<summary>
Action executed when client tries to join the channel.
You can either return `Ok` if channel allows join, or reject it with `Rejected`
Typical cases for rejection may include authorization/authentication,
not being able to handle more connections or other business logic reasons.

 As arguments, `join` action gets:
 *  current `HttpContext` for the request
 * `ClientInfo` instance representing additional information about client sending request
</summary>
</member>
<member name="M:Saturn.ChannelBuilder.ChannelBuilder.Handle``1(Saturn.ChannelBuilder.ChannelBuilderState,System.String,Microsoft.FSharp.Core.FSharpFunc{Microsoft.AspNetCore.Http.HttpContext,Microsoft.FSharp.Core.FSharpFunc{Saturn.Channels.ClientInfo,Microsoft.FSharp.Core.FSharpFunc{Saturn.Channels.Message{``0},System.Threading.Tasks.Task{Microsoft.FSharp.Core.Unit}}}})">
<summary>
Action executed when client sends a message to the channel to the given topic.

 As arguments, `handle` action gets:
 *  current `HttpContext` for the request
 * `ClientInfo` instance representing additional information about client sending request
 * `Message&lt;&apos;a&gt;` instance representing message sent from client to the channel
</summary>
</member>
<member name="M:Saturn.ChannelBuilder.ChannelBuilder.ErrorHandler(Saturn.ChannelBuilder.ChannelBuilderState,Microsoft.FSharp.Core.FSharpFunc{Microsoft.AspNetCore.Http.HttpContext,Microsoft.FSharp.Core.FSharpFunc{Saturn.Channels.ClientInfo,Microsoft.FSharp.Core.FSharpFunc{Saturn.Channels.Message{System.Object},Microsoft.FSharp.Core.FSharpFunc{System.Exception,System.Threading.Tasks.Task{Microsoft.FSharp.Core.Unit}}}}})">
<summary>
Action executed when unhandled exception happens in the
 As arguments, `not_found_handler` action gets:
 *  current `HttpContext` for the request
 * `ClientInfo` instance representing additional information about client sending request
 * `Message&lt;&apos;a&gt;` instance representing message sent from client to the channel
</summary>
</member>
<member name="T:Saturn.ChannelBuilder.ChannelBuilder">
<summary>
Computation expression used to create channels - an `controller`-like abstraction over WebSockets allowing real-time, and push-based communication between server and the client
 The messages handled by channels should be json-encoded, in a following form: `{Topic = &quot;my topic&quot;; Ref = &quot;unique-message-id&quot;; Payload = {...} }`

The result of the computation expression is the `IChannel` instance that can be registered in the `application` computation expression using `add_channel` operation.

**Example:**

 ```fsharp

 let browserRouter = router {
   get &quot;/ping&quot; (fun next ctx -&gt; task {
     let hub = ctx.GetService&amp;lt;Saturn.Channels.ISocketHub&gt;()
     match ctx.TryGetQueryStringValue &quot;message&quot; with
     | None -&gt;
       do! hub.SendMessageToClients &quot;/channel&quot; &quot;greeting&quot; &quot;hello&quot;
     | Some message -&gt;
       do! hub.SendMessageToClients &quot;/channel&quot; &quot;greeting&quot; (sprintf &quot;hello, %s&quot; message)
     return! Successful.ok (text &quot;Pinged the clients&quot;) next ctx
    })
   }

 let sampleChannel = channel {
   join (fun ctx si -&gt; task {
     ctx.GetLogger().LogInformation(&quot;Connected! Socket Id: &quot; + si.SocketId.ToString())
     return Ok
   })

   handle &quot;topic&quot; (fun ctx si msg -&gt;
     task {
        let logger = ctx.GetLogger()
        logger.LogInformation(&quot;got message {message} from client with Socket Id: {socketId}&quot;, msg, si.SocketId)
        return ()
   })
 }

 let app = application {
   use_router browserRouter
   url &quot;http://localhost:8085/&quot;
   add_channel &quot;/channel&quot; sampleChannel
 }
 ```
</summary>
</member>
<member name="T:Saturn.ChannelBuilder.ChannelBuilderState">
<summary>
Type representing internal state of the `channel` computation expression
</summary>
</member>
<member name="P:Saturn.ChannelBuilder.channel">
<summary>
Computation expression used to create channels
</summary>
</member>
<member name="T:Saturn.ChannelBuilder">
<summary>
Module with `channel` computation expression
</summary>
</member>
<member name="T:Saturn.Channels.SocketHub">
<summary>
 A type that wraps access to connected websockets by endpoint
</summary>
</member>
<member name="T:Saturn.Channels.ISocketHub">
<summary>
 Interface representing server side Socket Hub, giving you ability to brodcast messages (either to particular socket or to all sockets).
 You can get instance of it with `ctx.GetService&amp;lt;Saturn.Channels.ISocketHub&gt;()` from any place that has access to HttpContext instance (`controller` actions, `channel` actions, normal `HttpHandler`)
</summary>
</member>
<member name="T:Saturn.Channels.IChannel">
<summary>
 Interface of the internal representation of the channel.
 Shouldn&apos;t be used manually, you get its instance from the `channel` Computation Expression
</summary>
</member>
<member name="T:Saturn.Channels.JoinResult">
<summary>
Type representing result of `join` action. It can be either succesful (`Ok`) or you can reject client connection (`Rejected`)
</summary>
</member>
<member name="T:Saturn.Channels.ClientInfo">
<summary>
Type representing information about client that has executed some channel action
It&apos;s passed as an argument in channel actions (`join`, `handle`, `terminate`)
</summary>
</member>
<member name="T:Saturn.Channels.SocketId">
<summary>
Socket Id. Type alias for `Guid`
</summary>
</member>
<member name="T:Saturn.Channels.Message`1">
<summary>
 Types representing channels message.
 It always includes topic, reference id of the message (random GUID), and payload object.
</summary>
</member>
<member name="T:Saturn.Channels.Topic">
<summary>
Topic of the channel. Type alias for `string`
</summary>
</member>
<member name="T:Saturn.Channels.ChannelPath">
<summary>
Url (relative to root application url) on which channel is hosted. Type alias for `string`
</summary>
</member>
<member name="M:Saturn.Application.ApplicationBuilder.WebHostConfig(Saturn.Application.ApplicationState,Microsoft.FSharp.Core.FSharpFunc{Microsoft.AspNetCore.Hosting.IWebHostBuilder,Microsoft.AspNetCore.Hosting.IWebHostBuilder})">
<summary>
Adds custom web host configuration step.
</summary>
</member>
<member name="M:Saturn.Application.ApplicationBuilder.UseStatic(Saturn.Application.ApplicationState,System.String)">
<summary>
Enables using static file hosting.
</summary>
</member>
<member name="M:Saturn.Application.ApplicationBuilder.UsePolicy(Saturn.Application.ApplicationState,System.String,Microsoft.FSharp.Core.FSharpFunc{Microsoft.AspNetCore.Authorization.AuthorizationHandlerContext,System.Boolean})">
<summary>
Add custom policy, taking an `AuthorizationHandlerContext -&gt; bool`
</summary>
</member>
<member name="M:Saturn.Application.ApplicationBuilder.UseOAuthWithSettings(Saturn.Application.ApplicationState,System.String,System.String,Saturn.OAuth.OAuthSettings)">
<summary>
Enables simple custom OAuth authentication using parmeters provided with `OAuth.OAuthSettings` record.
Can be used to quickly implement default OAuth authentication for 3rd party providers.
</summary>
</member>
<member name="M:Saturn.Application.ApplicationBuilder.UseOAuthWithConfig(Saturn.Application.ApplicationState,System.String,Microsoft.FSharp.Core.FSharpFunc{Microsoft.AspNetCore.Authentication.OAuth.OAuthOptions,Microsoft.FSharp.Core.Unit})">
<summary>
Enables OAuth authentication with custom configuration
</summary>
</member>
<member name="M:Saturn.Application.ApplicationBuilder.UseJWTAuthConfig(Saturn.Application.ApplicationState,Microsoft.FSharp.Core.FSharpFunc{Microsoft.AspNetCore.Authentication.JwtBearer.JwtBearerOptions,Microsoft.FSharp.Core.Unit})">
<summary>
Enables JWT authentication with custom configuration
</summary>
</member>
<member name="M:Saturn.Application.ApplicationBuilder.UseJWTAuth(Saturn.Application.ApplicationState,System.String,System.String)">
<summary>
Enables default JWT authentication
</summary>
</member>
<member name="M:Saturn.Application.ApplicationBuilder.UseIIS(Saturn.Application.ApplicationState)">
<summary>
Enables IIS integration
</summary>
</member>
<member name="M:Saturn.Application.ApplicationBuilder.UseGZip(Saturn.Application.ApplicationState)">
<summary>
Enables gzip compression
</summary>
</member>
<member name="M:Saturn.Application.ApplicationBuilder.UseCustomXMLSerializer``1(Saturn.Application.ApplicationState,``0)">
<summary>
Replaces built in XML (de)serializer with custom serializer
</summary>
</member>
<member name="M:Saturn.Application.ApplicationBuilder.UseCustomJSONSerializer``1(Saturn.Application.ApplicationState,``0)">
<summary>
Replaces built in JSON.Net (de)serializer with custom serializer
</summary>
</member>
<member name="M:Saturn.Application.ApplicationBuilder.UseCors(Saturn.Application.ApplicationState,System.String,Microsoft.FSharp.Core.FSharpFunc{Microsoft.AspNetCore.Cors.Infrastructure.CorsPolicyBuilder,Microsoft.FSharp.Core.Unit})">
<summary>
Enables application level CORS protection
</summary>
</member>
<member name="M:Saturn.Application.ApplicationBuilder.UseCookiesAuthConfig(Saturn.Application.ApplicationState,Microsoft.FSharp.Core.FSharpFunc{Microsoft.AspNetCore.Authentication.Cookies.CookieAuthenticationOptions,Microsoft.FSharp.Core.Unit})">
<summary>
Enables cookies authentication with custom configuration
</summary>
</member>
<member name="M:Saturn.Application.ApplicationBuilder.UseCookiesAuth(Saturn.Application.ApplicationState,System.String)">
<summary>
Enables default cookies authentication
</summary>
</member>
<member name="M:Saturn.Application.ApplicationBuilder.UseAntiforgeryWithConfig(Saturn.Application.ApplicationState,Microsoft.FSharp.Core.FSharpFunc{Microsoft.AspNetCore.Antiforgery.AntiforgeryOptions,Microsoft.FSharp.Core.Unit})">
<summary>
Enables use of the `protectFromForgery` `pipeline` component and the `CSRF` features in general.
This overload allows for custom configuration of the subsystem, for more information see the `AntiforgeryOptions` class at https://github.com/aspnet/Antiforgery/blob/dev/src/Microsoft.AspNetCore.Antiforgery/AntiforgeryOptions.cs
</summary>
</member>
<member name="M:Saturn.Application.ApplicationBuilder.UseAntiforgery(Saturn.Application.ApplicationState)">
<summary>
Enables use of the `protectFromForgery` `pipeline` component and the `CSRF` features in general.
</summary>
</member>
<member name="M:Saturn.Application.ApplicationBuilder.Url(Saturn.Application.ApplicationState,System.String)">
<summary>
Adds url
</summary>
</member>
<member name="M:Saturn.Application.ApplicationBuilder.ServiceConfig(Saturn.Application.ApplicationState,Microsoft.FSharp.Core.FSharpFunc{Microsoft.Extensions.DependencyInjection.IServiceCollection,Microsoft.Extensions.DependencyInjection.IServiceCollection})">
<summary>
Adds custom service configuration step.
</summary>
</member>
<member name="M:Saturn.Application.ApplicationBuilder.Router(Saturn.Application.ApplicationState,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{Microsoft.AspNetCore.Http.HttpContext,System.Threading.Tasks.Task{Microsoft.FSharp.Core.FSharpOption{Microsoft.AspNetCore.Http.HttpContext}}},Microsoft.FSharp.Core.FSharpFunc{Microsoft.AspNetCore.Http.HttpContext,System.Threading.Tasks.Task{Microsoft.FSharp.Core.FSharpOption{Microsoft.AspNetCore.Http.HttpContext}}}})">
<summary>
Defines top-level router used for the application
</summary>
</member>
<member name="M:Saturn.Application.ApplicationBuilder.PipeThrough(Saturn.Application.ApplicationState,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{Microsoft.AspNetCore.Http.HttpContext,System.Threading.Tasks.Task{Microsoft.FSharp.Core.FSharpOption{Microsoft.AspNetCore.Http.HttpContext}}},Microsoft.FSharp.Core.FSharpFunc{Microsoft.AspNetCore.Http.HttpContext,System.Threading.Tasks.Task{Microsoft.FSharp.Core.FSharpOption{Microsoft.AspNetCore.Http.HttpContext}}}})">
<summary>
Adds pipeline to the list of pipelines that will be used for every request
</summary>
</member>
<member name="M:Saturn.Application.ApplicationBuilder.NoWebhost(Saturn.Application.ApplicationState)">
<summary>
Disables any configuration of webhost. Could be used for generic `IHostBuilder` applications not using Kestrel/IIS
</summary>
</member>
<member name="M:Saturn.Application.ApplicationBuilder.NoRouter(Saturn.Application.ApplicationState)">
<summary>
Disable warning message about lack of `router` definition. Should be used for channels-only or gRPC applications.
</summary>
</member>
<member name="M:Saturn.Application.ApplicationBuilder.MemoryCache(Saturn.Application.ApplicationState)">
<summary>
Enables in-memory session cache
</summary>
</member>
<member name="M:Saturn.Application.ApplicationBuilder.Logging(Saturn.Application.ApplicationState,Microsoft.FSharp.Core.FSharpFunc{Microsoft.Extensions.Logging.ILoggingBuilder,Microsoft.FSharp.Core.Unit})">
<summary>
Adds logging configuration.
</summary>
</member>
<member name="M:Saturn.Application.ApplicationBuilder.ListenLocal(Saturn.Application.ApplicationState,System.Int32,Microsoft.FSharp.Core.FSharpFunc{Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions,Microsoft.FSharp.Core.Unit})">
<summary>
 Listens on `::1` and `127.0.0.1` with the given port. Requesting a dynamic port by specifying `0` is not supported for this type of endpoint
</summary>
</member>
<member name="M:Saturn.Application.ApplicationBuilder.HostConfig(Saturn.Application.ApplicationState,Microsoft.FSharp.Core.FSharpFunc{Microsoft.Extensions.Hosting.IHostBuilder,Microsoft.Extensions.Hosting.IHostBuilder})">
<summary>
Adds custom generic host (`IHostBuilder`) configuration step. Configuration for web host should use `webhost_config` instead.
</summary>
</member>
<member name="M:Saturn.Application.ApplicationBuilder.ForceSSL(Saturn.Application.ApplicationState)">
<summary>
Redirect all HTTP request to HTTPS
</summary>
</member>
<member name="M:Saturn.Application.ApplicationBuilder.ErrorHandler(Saturn.Application.ApplicationState,Microsoft.FSharp.Core.FSharpFunc{System.Exception,Microsoft.FSharp.Core.FSharpFunc{Microsoft.Extensions.Logging.ILogger,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{Microsoft.AspNetCore.Http.HttpContext,System.Threading.Tasks.Task{Microsoft.FSharp.Core.FSharpOption{Microsoft.AspNetCore.Http.HttpContext}}},Microsoft.FSharp.Core.FSharpFunc{Microsoft.AspNetCore.Http.HttpContext,System.Threading.Tasks.Task{Microsoft.FSharp.Core.FSharpOption{Microsoft.AspNetCore.Http.HttpContext}}}}}})">
<summary>
Adds error/not-found handler for current scope
</summary>
</member>
<member name="M:Saturn.Application.ApplicationBuilder.DisableDiagnostics``1(``0)">
<summary>
Disables generation of diagnostic files that can be used by Saturn tooling.
</summary>
</member>
<member name="M:Saturn.Application.ApplicationBuilder.ConfigXMLSerializer(Saturn.Application.ApplicationState,System.Xml.XmlWriterSettings)">
<summary>
Configures built in XML (de)serializer with custom settings.
</summary>
</member>
<member name="M:Saturn.Application.ApplicationBuilder.ConfigJSONSerializer(Saturn.Application.ApplicationState,Newtonsoft.Json.JsonSerializerSettings)">
<summary>
Configures built in JSON.Net (de)serializer with custom settings.
</summary>
</member>
<member name="M:Saturn.Application.ApplicationBuilder.CliArguments(Saturn.Application.ApplicationState,System.String[])">
<summary>
Sets the cli arguments for the `IWebHostBuilder` to enable default command line configuration and functionality.
</summary>
</member>
<member name="M:Saturn.Application.ApplicationBuilder.AppConfig(Saturn.Application.ApplicationState,Microsoft.FSharp.Core.FSharpFunc{Microsoft.AspNetCore.Builder.IApplicationBuilder,Microsoft.AspNetCore.Builder.IApplicationBuilder})">
<summary>
Adds custom application configuration step.
</summary>
</member>
<member name="M:Saturn.Application.ApplicationBuilder.AddMimeTypes(Saturn.Application.ApplicationState,Microsoft.FSharp.Collections.FSharpList{System.Tuple{System.String,System.String}})">
<summary>
Adds MIME types definitions as a list of (extension, mime)
</summary>
</member>
<member name="M:Saturn.Application.ApplicationBuilder.AddChannel(Saturn.Application.ApplicationState,System.String,Saturn.Channels.IChannel)">
<summary>
Registers channel for given url.
</summary>
</member>
<member name="M:Saturn.Application.ApplicationBuilder.ActivateDeveloperExceptions(Saturn.Application.ApplicationState)">
<summary>
 Turns on the developer exception page, if the environment is in development mode.
</summary>
</member>
<member name="T:Saturn.Application.ApplicationBuilder">
<summary>
 Computation expression used to configure Saturn application.
 Under the hood it&apos;s using ASP.NET application configurations interfaces such as `IWebHostBuilder`, `IServiceCollection`, `IApplicationBuilder` and others.
 It aims to hide cumbersome ASP.NET application configuration and enable high level, declarative application configuration using feature toggles.

 **Example:**

 ```fsharp
 let app = application {
     pipe_through endpointPipe
     use_router topRouter
     url &quot;http://0.0.0.0:8085/&quot;
     memory_cache
     use_static &quot;static&quot;
     use_gzip
 }
 ```
</summary>
</member>
<member name="T:Saturn.Application.ApplicationState">
<summary>
Type representing internal state of the `application` computation expression
</summary>
</member>
<member name="M:Saturn.Application.run(Microsoft.Extensions.Hosting.IHostBuilder)">
<summary>
Runs Saturn application
</summary>
</member>
<member name="P:Saturn.Application.application">
<summary>
Computation expression used to configure Saturn application
</summary>
</member>
<member name="M:Saturn.Application.parseAndValidateOauthTicket(Microsoft.AspNetCore.Authentication.OAuth.OAuthCreatingTicketContext)">
<summary>
 generic oauth parse and validate logic, shared with the auth extensions package
</summary>
</member>
<member name="T:Saturn.Application.Config">
<summary>
Helpers for getting configuration
</summary>
</member>
<member name="T:Saturn.Application.Environment">
<summary>
Helpers for getting environment info
</summary>
</member>
<member name="T:Saturn.Application">
<summary>
Module containing `application` computation expression
</summary>
</member>
<member name="M:Saturn.Links.edit``1(Microsoft.AspNetCore.Http.HttpContext,``0)">
<summary>
Returns a link to the `edit` action for a particular resource of the same type as the current request.
</summary>
</member>
<member name="M:Saturn.Links.withId``1(Microsoft.AspNetCore.Http.HttpContext,``0)">
<summary>
Returns a link to the `withId` action for a particular resource of the same type as the current request.
</summary>
</member>
<member name="M:Saturn.Links.add(Microsoft.AspNetCore.Http.HttpContext)">
<summary>
Returns a link to the `add` action for the current model.
</summary>
</member>
<member name="M:Saturn.Links.index(Microsoft.AspNetCore.Http.HttpContext)">
<summary>
Returns a link to the `index` action for the current model.
</summary>
</member>
<member name="T:Saturn.Links">
<summary>
Convention-based links to other actions to perform on the current request model.
</summary>
</member>
</members>
</doc>
